### 面向对象



#### 参数的传递

如果是引用类型，传递的是参数的地址，如果是普通类型，传递的是参数的复制值。

```Java
public class Main {
    public static void main(String[] args) {
        String Bob = "Bob";
        Person p = new Person(Bob);
        System.out.println(p.getName());//Bob
        //change name
        Bob = "little Bob"; //这里是重新开辟了一个新的内存，赋值为little Bob,然后用变量Bob指向它（字符串的首地址）
        System.out.println(p.getName());//Bob
    }
}

class Person {
    private String name;
    public Person(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}
```

如果是这种情形，改变任何一个都会改变，因为他们是共同的地址，传入的是数组的首地址，这样当原来的数组改变的时候，地址没变，该地址的内容改变了。

```Java
public class Main {
    public static void main(String[] args) {
        String[] names = new String[]{"jack","sparrow"};
        Person p = new Person(names);
        p.getNames();//jack sparrow
        //change
        names[0] = "nobody";
        p.getNames();//nobody sparrow
    }
}

class Person {
    private String[] names;
    public Person(String[] names){
        this.names = names;
    }
    public void getNames(){
        for(String name:names){
            System.out.println(name);
        }
    }
}

```



#### 可变参数

用`...`来表示可变参数，即参数的数量可变，实际上是一个数组，接收的时候也要用数组类型来接收。

``` Java
public class Main {
    public static void main(String[] args) {
        Person p = new Person(new String[] {"jack","sparrow"}); //多个参数的情形下需要构造成数组的形式传入
        p.getNames();
    }
}

class Person {
    private String[] names;
    public Person(String[] names){
        this.names = names;
    }
    public void getNames(){
        for(String s:names){
            System.out.println(s);
        }
    }
}

```

可以改写成可变参数的情形

```Java
public class Main {
    public static void main(String[] args) {
        Person p = new Person("jack","sparrow");
        p.getNames();
    }
}

class Person {
    private String[] names;
    public Person(String... names){ //形参为可变参数，可以传入0或者任意个参数
        this.names = names;
    }
    public void getNames(){
        for(String s:names){
            System.out.println(s);
        }
    }
}

```



#### 继承

- Java只允许单继承，所有类最终的根类是`Object`，用`extends`关键字来继承，没写的默认继承自`Object`类。
- `prootected`关键字允许子类访问父类的字段和方法，而别的类不能访问。
- 子类可以调用父类的构造方法，注意到在子类的构造函数中，如果没有显示调用父类的构造方法，编译器将会自动加上`super()`来调用。如同没有写构造方法编译器会自动加上无参数的构造函数一样。
- 如果父类没有默认的构造方法，子类就必须显式调用`super()`并给出参数以便让编译器定位到父类的一个合适的构造方法



```Java
public class Main {
    public static void main(String[] args) {
        Student marry = new Student("marry",19,99);
        
    }
}

class Person {
    protected String name;
    protected  int age;
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;
    public Student(String name, int age, int score){
        super(name,age); //这里必须显式调用父类构造函数，否则编译器自动添加的super()会报错，因为父类没有这个构造函数
        this.score = score;
    }
}

```

#### 向上转型和向下转型

如果有以下继承关系`Object Person Student`

那么一般情况下是这么定义实例的：

```java
Person p = new Person();
Student s = new Student();
```

也可以这么定义实例

```java
Person p = new Student(); //因为Student是Person的子类，包含Person所定义的所有东西
Student s = new Person(); //错误，因为Student比Person多的成员无法凭空生成
```

上面的`Person p = new Student();`就是向上转型，这种写法是天然成立的。这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting），转型之后成为更抽象的类型。

对于下面的情况可能会出错

```java
Person p1 = new Student();
Person p2 = new Person();
//进行向下转型
Student s1 = (Student)p1; //正确的，因为p1就是Student实例
Student s2 = (Student)p2; //错误的，因为p2实际上是Person实例，多余的成员无法凭空生成
```

#### instanceof 操作符

首先定义两个类Person和Student，其中Student继承自Person类。

```Java
class Person {
    protected  String name;
    public Person(String name){
        this.name = name;
    }
}

class Student extends Person{
    protected int age;
    public Student(String name, int age){
        super(name);
        this.age = age;
    }
}
```

可以用该操作符判断实例是否为某个类

注意到如果一个实例是Student类型的，那么同时也是其父类Person类型的

``` java
public class Main {
    public static void main(String[] args) {
        Person p = new Person("jack");
        Student s = new Student("jack",10);
        Person p1 = new Student("jack",19);//向上转型，是正确的
//        Student s1 = (Student)p; //向下转型，错误 Person cannot be cast to Student
        Student s1 = (Student) p1; //向下转型，正确
        System.out.println(p1 instanceof Student);//true
        System.out.println(p1 instanceof Person);//true
        System.out.println(s1 instanceof Student);//true
        System.out.println(s1 instanceof Person);//true
    }
}
```

只有是该类的实例类型，才能进行转型。另外还有一种简便的写法在判断实例类型的同时转型。

```java
Object obj = "hello";
if(obj instanceof String s){
    //可以直接使用变量s
    System.out.println(s.toUpperCase());
}
```



#### 多态

引用变量的声明类型可能与其实际类型不符，例如

``` java
Person p = new Student(); // Student是Person类的子类
```

如果子类覆写了父类的方法，例如

```java
class Person {
    public void run(){
        System.out.println("Person.run()");
    }
}

class Student extends Person {
    @Override
    public void run(){
        System.out.println("Student.run()");
    }
}
```

当我们执行该覆写的方法的时候，调用规则是：**基于运行时的实际类型的动态调用**，而非变量的声明类型，这就是多态（Polymorphic）。

``` java
p.run();
```

> 注意覆写Override和重载Overload的区别：覆写是相同的函数名，相同的参数和返回值，可以用@Override编译器帮助检查覆写是否正确。而重载是相同的函数名，但是参数类型或者参数个数不同。尤其注意：返回类型的不同不能用来区分覆写或者重载，会报错。

在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用，`super`指向父类的实例对象。

```java
class Student extends Person {
    @Override
    public String hello(){
        return super.hello() + "!";
    }
}
```

如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`。

如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承。

对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。

```java
final class Person {//不能被继承
    public final String name; //一旦经过初始化则不能被改写
    public final void run(){ //不能被覆写Override
        ...
    }
}
```



#### 多态应用举例

一个计算税费的例子：基本收入税率为0.1，津贴税率为高于5000部分的0.2；

```Java
package  Main.java;

public class Main {
    public static void main(String[] args) {
        Income[] incomes = new Income[]{
                new Income(6000),
                new Salary(5500)
        };
        System.out.println(getTax(incomes)); //6000*0.1 + 500*0.2 = 700
    }

    public static double getTax(Income...incomes){
        double sumTax = 0;
        for(Income income:incomes){
            sumTax += income.getIncome(); //多态体现在这里，根据实际运行的类执行指定的方法

        }
        return sumTax;
    }
}

class Income {
    protected double income;
    public Income(double income){
        this.income = income;
    }
    public double getIncome() {
        return income*0.1;
    }
}

class Salary extends Income {
    public Salary(double income){
        super(income);
    }
    @Override
    public double getIncome(){
        if(income<5000){
            return 0;
        }else{
            return (income-5000)*0.2;
        }
    }
}
```



#### 覆写Object方法

所有的类都继承自`Object`类，该类定义了几个重要的方法，所有的类都可以对其进行覆写。

- `toString()`：把instance输出为`String`；
- `equals()`：判断两个instance是否逻辑相等；
- `hashCode()`：计算一个instance的哈希值



```java
public class Main {
    public static void main(String[] args) {
        Person jack = new Person("jack");
        Person marry = new Person("marry");
        System.out.println(jack.equals(marry)); //false
        System.out.println(jack.toString()); //class.Person jack
        System.out.println(jack.hashCode());
    }
}

class Person {
    public String name;
    public Person(String name){
        this.name = name;
    }
    @Override
    public String toString(){
        return "class.Person " + name;
    }
    @Override
    public boolean equals(Object o){
        return this.name.equals(((Person) o).name);
    }
    @Override
    public int hashCode(){
        return this.name.hashCode();
    }
}
```



#### 抽象方法和抽象类abstract

- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
- 如果不实现抽象方法，则该子类仍是一个抽象类；
- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现

同C++一致，定义了抽象方法的类必须是抽象类，抽象方法由其子类来具体实现，如果子类不实现，那么子类还是抽象类。

```Java
public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.run();
    }
}
//Person是一个抽象类，因为包含了抽象方法run
abstract class Person{
    public abstract void run();
}

class Student extends Person{
    @Override
    public void run(){
        System.out.println("Student.run()");
    }
}
```

> 注：Override关键字不是必须的，但是可以帮助检查是否错误，如果有错误编译不通过。



#### 接口interface

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。如果一个抽象类没有字段，所有方法全部都是抽象方法：

所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为**接口定义的所有方法默认都是`public abstract`的**，所以这两个修饰符不需要写出来（写不写效果都一样）。

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字。

> 接口就是比抽象类还抽象的类：接口连字段都没有，只有抽象方法。



####  静态字段和静态方法static

用`static`修饰的变量和函数就是静态字段和静态方法，不属于具体的某个实例，而是属于类的。

我们可以通过实例对象来访问静态成员是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态成员。

**推荐用类名来访问静态字段。**

静态方法经常用于工具类。例如：

- Arrays.sort()
- Math.random()

静态方法也经常用于辅助方法。注意到Java程序的入口`main()`也是静态方法。

```Java
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.count = 0; //可以通过实例对象来访问静态成员，但是不推荐
        System.out.println(Person.count);
        Person p2 = new Person();
        p2.count = -1;//任何一个实例对象都可以对静态成员做出改变
        System.out.println(Person.count);
    }
}

class Person {
    public static int count; //定义一个静态字段count
}
```

> 静态方法是属于类的，所以只能调用静态成员，不能调用实例变量

- 接口的静态字段

**接口是一个纯抽象类，所以不能定义实例字段**，但是可以定义静态字段，但是必须是final类型的

```java
public interface Person {
    public static final int MALE = 1;
    public static final int FEMAL = 2;
}
```

因为`interface`的字段只能是`public static final`类型的，所以可以省略，编译器会自动加上。

```java
public interface Person {
    int MALE = 1;
    int FEMALE = 2;
}
```

应用举例：统计创建实例的个数

```java
public class Main {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person();
        System.out.println(Person.getCount());//2
    }
}

class Person {
    public static int count = 0;//或者不初始化也行，int类型默认初始化为0
    public static int getCount(){
        return count;
    }
    public Person(){
        count++; //每次创建一个新的实例就加1
    }
}
```

#### 包package

Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时：

- 如果是完整类名，就直接根据完整类名查找这个`class`；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前`package`是否存在这个`class`；
  - 查找`import`的包是否包含这个`class`；
  - 查找`java.lang`包是否包含这个`class`。

如果按照上面的规则还无法确定类名，则编译报错。

编写class的时候，编译器会自动帮我们做两个import动作：

- 默认自动`import`当前`package`的其他`class`；
- 默认自动`import java.lang.*`。

包作用域：位于同一个包的类，可以访问包作用域的字段和方法。不用`public`、`protected`、`private`修饰的字段和方法就是包作用域。

```java
package  Main.java; //注意不要忘记分号
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.hello();
    }
}

class Person {
    void hello(){
        System.out.println("hello");
    }
}
```

#### 作用域

final的作用

- 修饰class：可以防止被继承
- 修饰method：可以防止被覆写
- 修饰field：可以防止被重新赋值
- 修饰局部变量：可以防止被重新赋值

一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类

`private`访问权限被限定在`class`的内部，而且与方法声明顺序*无关*。推荐把`private`方法放到后面，因为`public`方法定义了类对外提供的功能，阅读代码的时候，应该先关注`public`方法

由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问`private`的权限

#### 内部类

##### Inner class

定义的`Outer`是一个普通类，而`Inner`是一个`Inner Class`，它与普通类有个最大的不同，就是`Inner Class`的实例不能单独存在，必须依附于一个`Outer Class`的实例。

```java
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("jack"); //必须依附外部类的实例
        Outer.Inner inner = outer.new Inner();
        inner.hello();
    }
}

class Outer{
    private String name;
    Outer(String name){
        this.name = name;
    }
    //定义内部类，可以访问外部类的private成员，Outer.this即外部实例对象
    class Inner{
        void hello(){
            System.out.println("hello, "+Outer.this.name);
        }

    }
}
```

要实例化一个`Inner`，我们必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例

```java
Outer.Inner inner = outer.new Inner();
```

观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而`Inner`类被编译为`Outer$Inner.class`。



##### 匿名类

```java
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("jack");
        outer.asyncHello();
    }
}

class Outer{
    private String name;
    Outer(String name){
        this.name = name;
    }
    void asyncHello(){
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println("hello, "+Outer.this.name);
            }
        };
        new Thread(r).start();

    }
}
```

解释：在普通类`Outer`的函数`asyncHello`中实现了一个匿名类。

`Runnable`本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了`Runnable`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`Runnable`,定义匿名类的方法如下

```java
Runnable r = new Runnable() {
    // 实现必要的抽象方法...
};
```

匿名类和`Inner Class`一样，可以访问`Outer Class`的`private`字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义`Inner Class`可以少写很多代码。

观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`。如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`……

##### 静态内部类

用`static`修饰的内部类和`Inner Class`有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此无法引用`Outer.this`，但它可以访问`Outer`的`private`静态字段和静态方法。

```java
package  Main.java;
public class Main {
    public static void main(String[] args) {
        Person.Inner inner = new Person.Inner();//可以直接通过类名来定义
        inner.func();
    }
}

class Person {
    private static int age;
    private  static int getAge(){
        return age;
    }
    //静态内部类
    static class Inner{
        public void func(){
            //嵌套类可以访问类的private方法
            System.out.println(Person.getAge());
        }
    }
}
```



**小结**

Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：

- Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有`Outer.this`实例，并拥有Outer Class的`private`访问权限；
- Static Nested Class是独立类，但拥有Outer Class的`private`访问权限。



### Java核心

#### 字符串和编码

**比较两个字符串是否相等，必须用`equals`方法，而不能使用`==`**。

``` java
public class Main {
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = "HELLO";
        System.out.println(s1==s2);//true
        System.out.println(s1.equals(s2));//true
        System.out.println(s1==(s3.toLowerCase()));//false
        System.out.println(s1.equals(s3.toLowerCase()));//true
        System.out.println(s1.equalsIgnoreCase(s3));//true
    }
}
```

第一个True纯属巧合，Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然`s1`和`s2`的引用就是相同的。

要忽略大小写比较，使用`equalsIgnoreCase()`方法。

**String**

`String`是一个引用类型，本身也是一个`class`，实际上字符串在`String`内部是通过字符数组`char[]`来表示的，但是因为常用，`Java`提供了`"..."`的字面量表示方法。

Java字符串的一个重要特点就是字符串**不可变**。这种不可变性是通过内部的`private final char[]`字段，以及没有任何修改`char[]`的方法实现的。



String还提供了多种方法来搜索子串、提取子串，常用的方法有：

- 是否包含子串

  ```Java
  "Hello".contains("ll"); // true
  ```

  

- 搜索子串

  ```Java
  "Hello".indexOf("l"); //2
  "Hello".lastIndexOf("l");//3
  "Hello".startsWith("H");//true
  "Hello".endsWith("llo");//true
  ```

  

- 提取子串

  ```Java
  "Hello".substring(2);//llo
  "Hello".substring(2,4);//ll 不包含4
  ```

- 去除首尾空白字符串

  ```Java
  "  \tHello\r\n ".trim() //Hello
  ```

  

另一个`strip()`方法也可以移除字符串首尾空白字符。它和`trim()`不同的是，类似中文的空格字符`\u3000`也会被移除

​	

```Java
"\u3000Hello\u3000".strip(); // "Hello"
" Hello ".stripLeading(); // "Hello "
" Hello ".stripTrailing(); // " Hello"
```



- 判断是否为空以及是否为空白字符串

  ```Java
  "".isEmpty(); // true，因为字符串长度为0
  "  ".isEmpty(); // false，因为字符串长度不为0
  "  \n".isBlank(); // true，因为只包含空白字符
  " Hello ".isBlank(); // false，因为包含非空白字符
  ```

  > 是否为空，如果是空白字符也算字符，则不为空。

- 替换字符串

  ```Java
  String s = "hello";
  s.replace('l', 'w'); // "hewwo"，所有字符'l'被替换为'w'
  s.replace("ll", "~~"); // "he~~o"，所有子串"ll"被替换为"~~"
  ```

- 格式化字符串

  ```Java
  String s = "Hi %s, your score is %d!";
  System.out.println(s.formatted("Alice", 80));
  System.out.println(String.format("Hi %s, your score is %.2f!", "Bob", 59.5));
  ```

- 类型转换，转为String类型

要把任意基本类型或引用类型转换为字符串，可以使用静态方法`valueOf()`。这是一个重载方法，编译器会根据参数自动选择合适的方法

```Java
String.valueOf(123); // "123"
String.valueOf(45.67); // "45.67"
String.valueOf(true); // "true"
String.valueOf(new Object()); // 类似java.lang.Object@636be97c
```

- 字符串转为其他类型

  ```Java
  int n1 = Integer.parseInt("123"); // 123
  int n2 = Integer.parseInt("ff", 16); // 按十六进制转换，255
  ```

- String和字符串数组转换

  ```Java
  char[] cs = "Hello".toCharArray(); // String -> char[]
  String s = new String(cs); // char[] -> String
  ```

  如果修改了`char[]`数组，`String`并不会改变：

  这是因为通过`new String(char[])`创建新的`String`实例时，它并不会直接引用传入的`char[]`数组，而是会复制一份，所以，修改外部的`char[]`数组不会影响`String`实例内部的`char[]`数组，因为这是两个不同的数组。

  ```Java
  String s = "hello";
  char[] chars = s.toCharArray();
  chars[0] = '~';
  System.out.println(s);//hello，没有发生变化
  System.out.println(new String(chars)); // ~ello
  ----------------------------------------
  char[] chars = "hello".toCharArray();
  String s = new String(chars);
  chars[0] = 'X';
  System.out.println(s); //hello没有因为数组修改而发生变化，因为new String(chars)是复制了内容
  
  ```

  

#### StringBuilder

为了能==**高效拼接字符串**==，Java标准库提供了`StringBuilder`，它是一个可变对象，可以**预分配缓冲区**，这样，往`StringBuilder`中新增字符时，不会创建新的临时对象：

```java
public class Main {
    public static void main(String[] args) {
        StringBuilder builder = new StringBuilder(1024);
        for(int i=0;i<10;i++){
            builder.append(i);
            builder.append(',');
        }
        String s = builder.toString();
        System.out.println(s);
        //输出：0,1,2,3,4,5,6,7,8,9,
    }
}
```

**链式操作**

进行链式操作的关键是，定义的`append()`方法会返回`this`，这样就可以不断调用`append()`方法了。

```java
public class Main {
    public static void main(String[] args) {
        StringBuilder builder = new StringBuilder(1024);
        builder.append("hello").append(',').append(" world!");
        String s = builder.toString();
        System.out.println(s);
        //输出：hello, world!
    }
}
```

**链式操作应用举例**

``` java
package  Main.java;

public class Main {
    public static void main(String[] args) {
        Adder adder = new Adder();
        adder.add(2).inc(); //链式操作
        System.out.println(adder.value()); //3 
    }
}
//设计一个加法器
class Adder{
    private int count = 0;

    public Adder add(int n){
        count += n;
        return this;
    }
    public Adder inc(){
        count++;
        return this;
    }
    public int value(){
        return this.count;
    }
}
```

**构建SQL语句的例子**

``` java
public class Main {
    public static void main(String[] args) {
        String[] fields = {"name", "position", "salary"};
        String table = "employee";
        String insert = buildInsertSql(table, fields);
        System.out.println(insert);
    }
    static String buildInsertSql(String table, String[] fields){
        StringBuilder builder = new StringBuilder();
        builder.append("INSERT INTO ").append(table).append(" (").append(String.join(",",fields)).
                append(") VALUES (?, ?, ?)");
        return builder.toString();

    }

}
//输出： INSERT INTO employee (name,position,salary) VALUES (?, ?, ?);
```

> 注意这里用到了String.join("," , fields)以及最后用到了toString()方法将StringBuilder对象转为字符串。
>
> 且逗号分隔符必须用双引号，单引号会报错。

#### StringJoiner

用来解决**用分隔符拼接数组的需求**，实际上`String`的`join`静态方法就是调用了`StringJoiner`。



```java
public class Main {
    public static void main(String[] args) {
        String[] fields = {"name", "position", "salary"};
        String table = "employee";
        String select = buildSelectSql(table, fields);
        System.out.println(select);
    }
    static String buildSelectSql(String table, String[] fields){
        StringJoiner joiner = new StringJoiner(", "); //指定分隔符
        for(String s: fields){
            joiner.add(s); //注意StringJoiner是add方法，不是append方法
        }
        return "SELECT " + joiner.toString() + " FROM " + table + ";"; //直接拼接字符串
    }

}
```

用`StringJoiner`拼接字符串时，还可以额外附加一个“开头”和“结尾”。

``` java
import java.util.StringJoiner;

public class Main {
    public static void main(String[] args) {
        String[] names = {"jack", "bob", "marry"};
        StringJoiner joiner = new StringJoiner(", ", "Hello ", "!");//指定分隔符，开头和结尾
        for(String name: names){
            joiner.add(name);
        }
        System.out.println(joiner.toString());
        //输出：Hello jack, bob, marry!
    }
}
```

用指定分隔符拼接字符串数组时，使用`StringJoiner`或者`String.join()`更方便。

#### 包装类型

Java的数据类型分两种：

- 基本类型：`byte`，`short`，`int`，`long`，`boolean`，`float`，`double`，`char`
- 引用类型：所有`class`和`interface`类型

如何把一个基本类型视为对象（引用类型）？就需要用到包装类型。因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：可以直接使用而不用定义。

```
Integer Character Boolean Byte Short Long Float Double
int 	char	  bool	  byte short long float double
```

**`Integer`应用举例**

```java
int i = 100;
Integer integer = new Integer(i); //不推荐，会有编译错误
Integer integer2 = Integer.valueOf(100); //通过静态方法valueOf(int)创建
Integer integer3 = Integer.valueOf("100");//通过静态方法valueOf(String)创建
System.out.println(integer.intValue());
System.out.println(integer2.intValue());
System.out.println(integer3.intValue());
```

因为`int`和`Integer`可以互相转化

```java
int i = 100;
Integer n = Integer.valueOf(i); //auto boxing 自动装箱过程
int x = n.intValue();//auto unboxing 
----------------------------------
//代码可以这样写，简洁，编译器会转化为上面的写法
Integer n = 100; //自动装箱过程
int x = n; //自动拆箱过程
------------------------------------
Integer n = null;
int x = n;
//拆箱过程中报错： NullPointerException
```

对两个`Integer`实例进行比较要特别注意：绝对不能用`==`比较，因为`Integer`是引用类型，必须使用`equals()`比较：

#### JavaBean

在Java中，有很多`class`的定义都符合这样的规范：

- 若干`private`实例字段；
- 通过`public`方法来读写实例字段

JavaBean是一种符合命名规范的`class`，它通过`getter`和`setter`来定义属性。



#### 枚举类

可以在类中用`static final`来定义常量。

```java
class Weekday {
    public static final int MON = 0;
    public static final int TUE = 1;
    ...
    -------------------------------
    public static final String RED = 'r';
}
```

这种方法用来枚举常量一个缺点是：编译器无法检查每个值的合理性。

**Enum** 关键字

实际上这个也是一个类，继承自`Enum`类。只不过相对于普通的类进行了诸多限制。

```java
enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```

使用`enum`定义的枚举类**是一种引用类型**。引用类型比较，要使用`equals()`方法，**如果使用`==`比较，它比较的是两个引用类型的变量是否是同一个对象**。因此，引用类型比较，要始终使用`equals()`方法，但`enum`类型可以例外。

这是因为**`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较**：

`enum`定义的类型就是`class`，只不过它有以下几个特点：

- 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承；
- 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将`enum`类型用于`switch`语句。

```java
//如下定义
public enum Color {
    RED, GREEN, BLUE;
}
-----------------------编译器可能改成如下形式---------------------------
public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
```

因为`enum`是一个`class`，每个枚举的值都是`class`实例，因此，这些实例有一些方法：例如`name()`方法，`ordinal()`方法。

```java
public enum Color {
    RED, GREEN, BLUE;
}
String s = Color.RED.name(); //"RED"
int i = Color.RED.ordinal(); //0
```

要编写健壮的代码，就不要依靠`ordinal()`的返回值。因为`enum`本身是`class`，所以我们可以定义`private`的构造方法，并且，给每个枚举常量**添加字段**：

```java
enum Color {
    RED(1),GREEN(2),BLUE(3); //指定特定的值
    public final int value;
    private Color(int value){
        this.value = value;
    }
}
```

默认情况下，对枚举常量调用`toString()`会返回和`name()`一样的字符串。但是，==`toString()`可以被覆写，而`name()`则不行==。

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(Weekday.MON);//星期一，输出实例对象相当于调用了该对象的toString()方法，而该方法被覆写了
        System.out.println(Weekday.MON.ordinal());//0
        System.out.println(Weekday.MON.value);//1
        System.out.println(Weekday.MON.name());//MON
    }
}

enum Weekday {
    MON(1, "星期一"), TUE(2, "星期二"), WED(3, "星期三"), THU(4, "星期四"), FRI(5, "星期五"), SAT(6, "星期六"), SUN(0, "星期日");
    private final int value;
    private final String chinese;
    private Weekday(int value, String chinese){ //外部不能使用new来创建对象
        this.value = value;
        this.chinese = chinese;
    }
    @Override
    public String toString(){
        return chinese;
    }
}

```



#### 记录类



#### BigInteger



#### BigDecimal



#### 常用工具类

##### Math

常见的操作有：

```java
Math.max(1,2)
Math.abs(-1.2)
Math.pow(2,10)
Math.sqrt(2)
Math.log(Math.E)
Math.log10(100)
Math.sin(1)
Math.PI
Math.random()
```



##### Random

`Random`用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。

```java
Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
```

如果设定`seed`，那么多次运行的随机数都是一样的。

```java
public class Main {
    public static void main(String[] args) {
        Random random = new Random(0);
        for(int i=0;i<3;i++){
            System.out.println(random.nextInt());
        }
    }
}
```

`Math.random()`实际上内部调用了`Random`类，所以它也是伪随机数，只是无法指定种子。

> 对比真随机数，所谓的伪随机数是可以控制让它不”随机“的，也就是指定种子的时候，而真随机数是根据许多随机事件来给定的。

##### SecureRandom

真随机数： `SecureRandom`的安全性是**通过操作系统提供的安全的随机种子来生成随机数**。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。

