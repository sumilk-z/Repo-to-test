### 泛型

[参考链接1](https://www.jb51.net/article/216499.htm)

[参考链接2](https://blog.csdn.net/qq_41701956/article/details/123473592)

[参考链接3](https://blog.csdn.net/sunxianghuang/article/details/51982979?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-51982979-blog-123473592.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3-51982979-blog-123473592.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=5)

[泛型方法](http://home.ustc.edu.cn/~xie1993/java/java-generics.html)

#### 泛型方法

```java
public class MaximumTest
{
   // 比较三个值并返回最大值
   public static <T extends Comparable<T>> T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设x是初始最大值
      if ( y.compareTo( max ) > 0 ){
         max = y; //y 更大 
      }
      if ( z.compareTo( max ) > 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( "Max of %d, %d and %d is %d\n\n",
                   3, 4, 5, maximum( 3, 4, 5 ) );
 
      System.out.printf( "Maxm of %.1f,%.1f and %.1f is %.1f\n\n",
                   6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
 
      System.out.printf( "Max of %s, %s and %s is %s\n","pear",
         "apple", "orange", maximum( "pear", "apple", "orange" ) );
   }
}
```



#### 泛型类

```java
public class ArrayList<T> {
    private T[] array;
    private int size;
    public void add(T e){...}
    public void remove(int index){...}
    public T get(int index){...}
}
```

使用模板:由编译器对类型进行检查

```java
ArrayList<String> strList = new ArrayList<String>();
//或者也可以省略后面的具体类型
ArrayList<String> strList = new ArrayList<>();
```



**向上转型** 

在Java的标准库中的`ArrayList<T>`实现了`List<T>`接口，它可以向上转型为`List<T>`

```java
public class ArrayList<T> implements List<T>{
    ...
}
List<String> list = new ArrayList<String>();
```

> *特别注意*：不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`或`List<Number>`



#### 泛型接口

除了`ArrayList<T>`使用了泛型，还可以在接口中使用泛型。例如，`Arrays.sort(Object[])`可以对任意数组进行排序，但待排序的元素必须实现`Comparable<T>`这个泛型接口

```java
public interface Comparable<T>{
    int compareTo(T o); //该接口里的方法
    /**
    *返回负数：当前实例比参数o小
    *返回0：当前实例和参数o相等
    *返回正数：当前实例比参数o大
    **/
}
```

可以直接对`String`类型进行排序，因为`String`本身已经实现了`Comparable<String>`接口

```java
String[] strings = {"banana", "apple", "orange"};
Arrays.sort(strings);
System.out.println(Arrays.toString(strings)); //[apple, banana, orange]
```



**实现`Comparable<T>`接口的例子**

```Java
public class Main {
    public static void main(String[] args)  {
        Person alice = new Person("Alice",20);
        Person bob = new Person("Bob", 18);
        int i = bob.compareTo(alice);
        System.out.println(i); //1表示bob比alice大，即b比a大

        //或者放到数组中进行排序
        Person[] people = new Person[]{
                alice,bob
        };
        Arrays.sort(people);
        System.out.println(Arrays.toString(people)); //[Alice 20, Bob 18]
    }
}

class Person implements Comparable<Person>{
    String name;
    int age;
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person o) {
        return this.name.compareTo(o.name); //String类型已经实现了该接口
    }

    @Override
    public String toString(){
        return name + " " + age;
    }
}
```

可以设计成先根据年龄排序，再根据姓名排序，默认都是升序。

```java
@Override
public int compareTo(Person o) {
    //先根据年龄排序，再根据姓名排序
    int ageVale = age - o.age;
    if(ageVale==0){
        //年龄相同，比较姓名
        return name.compareTo(o.name);
    }
    return ageVale;
}
```

#### 编写泛型

很少会编写泛型，但是也需要掌握技巧；

```java
class Pair<T>{
    private T first;
    private T second;
    public Pair(T first, T second){
        this.first = first;
        this.second = second;
    }
    public T getFirst(){
        return this.first;
    }
    public T getSecond(){
        return this.second;
    }

}
```

##### **多个泛型类型**

```java
class Pair<T,K>{
    private T first;
    private K second;
    public Pair(T first, K second){
        this.first = first;
        this.second = second;
    }
    public T getFirst(){
        return this.first;
    }
    public K getSecond(){
        return this.second;
    }
}
```

```java
Pair<Integer,String > pair = new Pair<>(1,"sparrow");
```

Java标准库的`Map<K, V>`就是使用两种泛型类型的例子。

#####  **静态方法的泛型**

(实际上可以认为是普通的泛型方法，因为他不属于类，不能用泛型类的参数T)

编写泛型类时，要特别注意，**泛型类型`<T>`不能用于静态方法**。参考==[Java静态方法和泛型](https://blog.csdn.net/Vector97/article/details/110184768)==。

因为：在Java中泛型只是一个占位符，必须在传递类型后才能使用。

对于如下泛型的使用

```java
ArrayList<String> strList = new ArrayList<>();
```

前面已经声明了所传递的类型为`String`，后面可以省略不写。随着`new`的运行，开始实例化该泛型类（编译器已经知道指定`T`为`String`了）。

由于静态方法的加载优先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数时，静态方法就已经加载完成了。

所以这样使用时会报错

```java
public static Pair<T> func(T e1, T e2){...}
```

因为此时静态方法先加载，编译器并不知道T具体应该是什么类型。



但是，**静态方法可以定义自己的泛型**：

```java
public static <T> Pair<T> func(T e1, T e2){...}
```

这里的第一个`<T>`是声明该静态方法所用的泛型类型为`T`，实际上这个`T`和类中的非静态方法的参数`T`已经不是同一个东西了。

所以完全可以替换成别的字符以作区分：

```java
public static <U> Pair<U> func(U e1, U e2){...}
```

```java
class Pair<T,K>{
    private T first;
    private K second;
    public Pair(T first, K second){
        this.first = first;
        this.second = second;
    }
    public T getFirst(){
        return this.first;
    }
    public K getSecond(){
        return this.second;
    }
    public static <U,V> Pair<U,V> creat(U first, V second){
        return new Pair<U,V>(first,second);
    }

}
```

如果理解了上面的内容，也就不难理解这段定义了：

```java
public static <U,V> Pair<U,V> creat(U first, V second){
    return new Pair<U,V>(first,second);
}
```

实际上，因为编译器在形参中已经知道`U`，`V`的具体类型，也就知道`first`,`second`参数的具体类型，所以这么写也是正确的

```java
return new Pair<>(first,second);
```

具体调用方法

```java
Pair<Integer, String> jack = Pair.creat(1, "jack");
```

#### 擦拭法 type erasure

Java 语言的泛型实现方法是擦拭法。

用一句话来说就是虚拟机对于泛型一无所知，所有的工作都是编译器做的，编译器自动将泛型类型`<T>`转化为指定的类型。

对于泛型的源代码：

```java
public class Pair<T>{
    private T first;
    private T last;
    public Pair(T first, T last){
        this.first = first;
        this.last = last;
    }
    public T getFirst(){
        return this.first;
    }
    public T getLast(){
        return this.last;
    }
}
```

编译器将其更改为，这也是Java虚拟机执行的代码。

```java
public class Pair{
    private Object first;
    private Object last;
    public Pair(Object first, Object last){
        this.first = first;
        this.last = last;
    }
    public Object getFirst(){
        return this.first;
    }
    public Object getLast(){
        return this.last;
    }
}
```

- 编译器把类型`<T>`视为`Object`；
- 编译器根据`<T>`实现安全的强制转型。

Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型`T`视为`Object`处理。

##### type erasure的局限性

这就导致了以下局限：

- `<T>`不能是基本类型，例如`int`，因为实际类型是`Object`，`Object`类型无法持有基本类型：

  ```java
  Pair<int> p = new Pair<>(); //编译错误 Type argument cannot be of primitive type
  ```

- 无法取得带泛型的`Class`

  ```java
  Pair<String> p1 = new Pair<>("hello","world");
  Pair<Integer> p2 = new Pair<>(1,2);
  Class c1 = p1.getClass();
  Class c2 = p2.getClass();
  System.out.println(c1==c2);//true
  System.out.println(c1==Pair.class);//true
  ```

  因为`T`是`Object`，我们对`Pair<String>`和`Pair<Integer>`类型获取`Class`时，获取到的是同一个`Class`，也就是`Pair`类的`Class`。

  换句话说，所有泛型实例，无论`T`的类型是什么，`getClass()`返回同一个`Class`实例，因为编译后它们全部都是`Pair<Object>`

- 无法判断带泛型的类型

  ```Java
  Pair<String> p1 = new Pair<>("hello","world");
  System.out.println(p1 instanceof Pair<String>); //Illegal generic type for instanceof 无法判断具体的类型
  ```

  原因和前面一样，并不存在`Pair<String>.class`，而是只有唯一的`Pair.class`

- 不能实例化`T`类型 

  ```java
  //Type parameter 'T' cannot be instantiated directly
  public Pair(){
      first = new T();
      second = new T();
  }
  ```

  因为变成了

  ```java
  first = new Object();
  last = new Object();
  ```

  这样一来，创建`new Pair<String>()`和创建`new Pair<Integer>()`就全部成了`Object`,显然编译器要阻止这种类型不对的代码。

  > (理解：我要创建两种不同类型的泛型，但是都变成了Object类型，那还不如直接阻止这种用法。)

要实例化`T`类型，我们必须借助额外的`Class<T>`参数：

```java
public Pair(Class<T> cls) throws InstantiationException, IllegalAccessException {
    first = cls.newInstance();
    second = cls.newInstance();
}
```



上述代码借助`Class<T>`参数并通过反射来实例化`T`类型，使用的时候，也必须传入`Class<T>`

```java
 Pair<String> p = new Pair<>(String.class); //但是这样做多少显得有些愚蠢和多此一举?
```

> 网友的理解：为什么这在某些情形下是有意义的：借助`class.newInstance()`创建实例时编译器要求强制处理可能出现的异常，相当于做了兼容。直接`new`的话如果泛型类型为抽象类，则会出错。

- 不恰当的覆写方法

  ```java
  public class Pair<T>{
      public boolean equals(T t){
          return this == t;
      }
  }
  ```

  定义的`equals(T t)`会被擦拭成`equals(Object t)`,而`Object`是`Pair<T>` 的父类，在子类中定义这种方法相当于对父类方法进行覆写。**编译器会阻止一个实际上会变成覆写的泛型方法定义**。

解决方法：换个方法名，避开与`Object.equals(Object)`的冲突就可以成功编译。

> 问题：那假如我就是想要重写父类的方法呢？

有上述问题说明没有彻底理解这里。

实际上应该是：在父类Object中也有一个叫做equals的方法，定义为：

```java
public boolean equals(Object t){
    ...
}
```

而我们在泛型类中定义的泛型方法经过类型擦除之后也变成了这样：函数名相同，参数类型，个数相同，返回类型也相同，相当于对父类方法进行了覆写。而这个方法有可能不被允许覆写，或者说：程序员在不知情的情况下对其进行了覆写（程序员可能只是想编写一个普通的方法，但是没想到会对父类方法进行覆写），因此**编译器直接不允许在泛型类中定义和父类方法名相同的方法**，以防止程序员犯不知情的错误。

```java
public boolean equals(T t){
    ...
}
//经过type erasure之后
public boolean equals(Object t){
    ...
}
```



##### 泛型继承

**一个类可以继承自一个泛型类。**例如：父类的类型是`Pair<Integer>`，子类的类型是`IntPair`

```java
public class IntPair extends Pair<Integer> {
}
```

使用的时候，因为子类`IntPair`并没有泛型类型，所以，正常使用即可：

```java
IntPair ip = new IntPair(1, 2);
```

前面讲了，我们无法获取`Pair<T>`的`T`类型，即给定一个变量`Pair<Integer> p`，无法从`p`中获取到`Integer`类型。

但是，在父类是泛型类型的情况下，**编译器就必须把类型`T`（对`IntPair`来说，也就是`Integer`类型）保存到子类的class文件中，不然编译器就不知道`IntPair`只能存取`Integer`这种类型。**

在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：`IntPair`可以获取到父类的泛型类型`Integer`。获取父类的泛型类型代码比较复杂：

> 先记录下来，需要的时候再回来看。

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public class Main {
    public static void main(String[] args) {
        Class<IntPair> clazz = IntPair.class;
        Type t = clazz.getGenericSuperclass();
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型
            Type firstType = types[0]; // 取第一个泛型类型
            Class<?> typeClass = (Class<?>) firstType;
            System.out.println(typeClass); // Integer
        }

    }
}

class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}

class IntPair extends Pair<Integer> {
    public IntPair(Integer first, Integer last) {
        super(first, last);
    }
}
```



##### 小结

Java的泛型是采用擦拭法实现的；

擦拭法决定了泛型`<T>`：

- 不能是基本类型，例如：`int`；
- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`；
- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`；
- 不能实例化`T`类型，例如：`new T()`。

泛型方法要防止重复定义方法，例如：`public boolean equals(T obj)`；

子类可以获取父类的泛型类型`<T>`。



#### 通配符

限定通配符对类型进行了限制。有两种限定通配符，一种是`<? extends T>`它通过确保类型必须是`T`的子类来设定类型的上界，另一种是`<? super T>`它通过确保类型必须是`T`的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面`<?>`表示了非限定通配符，因为`<?>`可以用任意类型来替代。


##### ？通配符

无界通配符 无边界的通配符的主要作用就是让泛型能够接受未知类型的数据。

##### extends通配符

上界通配符upper bounds wildcards `<? extends E>`

使用**固定上边界**的通配符的泛型, 就能够接受指定类及其子类类型的数据。

例如对如下的静态方法，形参类型使用了通配符。

```java
static int add(Pair<? extends Number> p) {
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    }

class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
```

除了可以传入`Pair<Integer>`类型，我们还可以传入`Pair<Double>`类型，`Pair<BigDecimal>`类型等等，因为`Double`和`BigDecimal`都是`Number`的子类。

```java
//调用时：
Pair<Integer> p = new Pair<>(123, 456);
int n = add(p);
//或者可以
Pair<Double> p = new Pair<>(1.0,2.0);
double d = add(p);
```



##### super通配符

下界通配符 `<? super E>`

使用固定下边界的通配符的泛型, 就能够接受指定类及其父类类型的数据.。

> 注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界。



##### 对比extends和super通配符

我们再回顾一下`extends`通配符。作为方法参数，`<? extends T>`类型和`<? super T>`类型的区别在于：

- `<? extends T>`允许调用读方法`T get()`获取`T`的引用，但不允许调用写方法`set(T)`传入`T`的引用（传入`null`除外）；
- `<? super T>`允许调用写方法`set(T)`传入`T`的引用，但不允许调用读方法`T get()`获取`T`的引用（获取`Object`除外）。

一个是允许读不允许写，另一个是允许写不允许读。

先记住上面的结论，我们来看Java标准库的`Collections`类定义的`copy()`方法：

```Java
public class Collections {
    // 把src的每个元素复制到dest中:
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i=0; i<src.size(); i++) {
            T t = src.get(i);
            dest.add(t);
        }
    }
}
```

它的作用是把一个`List`的每个元素依次添加到另一个`List`中。它的第一个参数是`List<? super T>`，表示目标`List`，第二个参数`List<? extends T>`，表示要复制的`List`。我们可以简单地用`for`循环实现复制。在`for`循环中，我们可以看到，对于类型`<? extends T>`的变量`src`，我们可以安全地获取类型`T`的引用，而对于类型`<? super T>`的变量`dest`，我们可以安全地传入`T`的引用。

这个`copy()`方法的定义就完美地展示了`extends`和`super`的意图：

- `copy()`方法内部不会读取`dest`，因为不能调用`dest.get()`来获取`T`的引用；
- `copy()`方法内部也不会修改`src`，因为不能调用`src.add(T)`。

这是由编译器检查来实现的。如果在方法代码中意外修改了`src`，或者意外读取了`dest`，就会导致一个编译错误：

```Java
public class Collections {
    // 把src的每个元素复制到dest中:
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        ...
        T t = dest.get(0); // compile error!
        src.add(t); // compile error!
    }
}
```

这个`copy()`方法的另一个好处是可以安全地把一个`List<Integer>`添加到`List<Number>`，但是无法反过来添加：

```Java
// copy List<Integer> to List<Number> ok:
List<Number> numList = ...;
List<Integer> intList = ...;
Collections.copy(numList, intList);

// ERROR: cannot copy List<Number> to List<Integer>:
Collections.copy(intList, numList);
```

而这些都是通过`super`和`extends`通配符，并由编译器强制检查来实现的。

##### PECS原则

何时使用`extends`，何时使用`super`？为了便于记忆，我们可以用PECS原则：**Producer Extends Consumer Super**。

即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。

我们已经讨论了`<? extends T>`和`<? super T>`作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个`?`：

```
void sample(Pair<?> p) {
}
```

因为`<?>`通配符既没有`extends`，也没有`super`，因此：

- 不允许调用`set(T)`方法并传入引用（`null`除外）；
- 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）。

换句话说，**既不能读，也不能写**，那只能做一些`null`判断：

```
static boolean isNull(Pair<?> p) {
    return p.getFirst() == null || p.getLast() == null;
}
```

大多数情况下，可以引入泛型参数`<T>`消除`<?>`通配符：

```
static <T> boolean isNull(Pair<T> p) {
    return p.getFirst() == null || p.getLast() == null;
}
```

`<?>`通配符有一个独特的特点，就是：`Pair<?>`是所有`Pair<T>`的超类

```java
public static void main(String[] args) {
    Pair<Integer> p = new Pair<>(123, 456);
    Pair<?> p2 = p; // 安全地向上转型
    System.out.println(p2.getFirst() + ", " + p2.getLast());
}
```



### 集合Collection

Java标准库自带的`java.util`包提供了集合类：`Collection`，它是除`Map`外所有其他集合类的根接口。Java的`java.util`包主要提供了以下三种类型的集合：

- `List`：一种有序列表的集合，例如，按索引排列的`Student`的`List`；
- `Set`：一种保证没有重复元素的集合，例如，所有无重复名称的`Student`的`Set`；
- `Map`：一种通过键值（key-value）查找的映射表集合，例如，根据`Student`的`name`查找对应`Student`的`Map`。

Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是`List`，具体的实现类有`ArrayList`，`LinkedList`等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素。最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。

#### List

考察`List<E>`接口，可以看到几个主要的接口方法：

- 在末尾添加一个元素：`boolean add(E e)`
- 在指定索引添加一个元素：`boolean add(int index, E e)`
- 删除指定索引的元素：`E remove(int index)`
- 删除某个元素：`boolean remove(Object e)`
- 获取指定索引的元素：`E get(int index)`
- 获取链表大小（包含元素的个数）：`int size()`

实现`List`接口并非只能通过数组（即`ArrayList`的实现方式）来实现，另一种`LinkedList`通过“链表”也实现了List接口。

```java
List<String> list = new ArrayList<>();
list.add("apple"); // size=1
list.add("pear"); // size=2
list.add("apple"); // 允许重复添加元素，size=3
```

还允许添加null

```java
list.add(null); 
```

除了使用`ArrayList`和`LinkedList`，我们还可以通过`List`接口提供的`of()`方法，根据给定元素快速创建`List`

```java
List<Integer> list = List.of(1, 2, 5);
```

但是`List.of()`方法不接受`null`值，如果传入`null`，会抛出`NullPointerException`异常

**遍历List**

```java
List<String> list = List.of("apple", "pear", "banana");
for (int i=0; i<list.size(); i++) {
    String s = list.get(i);
    System.out.println(s);
}
```

不推荐该方法，`get(int)`方法只有`ArrayList`的实现是高效的，换成`LinkedList`后，索引越大，访问速度越慢。

`Iterator`本身也是一个对象，但它是由`List`的实例调用`iterator()`方法的时候创建的。`Iterator`对象知道如何遍历一个`List`，并且不同的`List`类型，返回的`Iterator`对象实现也是不同的，但总是具有最高的访问效率。

`Iterator`对象有两个方法：`boolean hasNext()`判断是否有下一个元素，`E next()`返回下一个元素。因此，使用`Iterator`遍历`List`代码如下：

```java
public static void main(String[] args) {
    List<String> list = List.of("apple", "pear", "banana");
    for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
        String s = it.next();
        System.out.println(s);
    }
}
```

Java的`for each`循环本身就可以帮我们使用`Iterator`遍历

```java
List<String> list = List.of("apple", "pear", "banana");
for (String s : list) {
    System.out.println(s);
}
```

实际上，只要实现了`Iterable`接口的集合类都可以直接用`for each`循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把`for each`循环变成`Iterator`的调用，原因就在于`Iterable`接口定义了一个`Iterator<E> iterator()`方法，强迫集合类必须返回一个`Iterator`实例。



`List`内部并不是通过`==`判断两个元素是否相等，而是使用`equals()`方法判断两个元素是否相等，例如`contains()`方法可以实现如下：

```java
public boolean contains(Object o) {
    for (int i = 0; i < elementData.length; i++) {
        if (o.equals(elementData[i])) {
            return true;
        }
    }
    return false;
}
```

要正确使用`List`的`contains()`、`indexOf()`这些方法，放入的实例必须正确覆写`equals()`方法，否则，放进去的实例，查找不到。我们之所以能正常放入`String`、`Integer`这些对象，是因为Java标准库定义的这些类已经正确实现了`equals()`方法。

如何正确编写`equals()`方法？`equals()`方法要求我们必须满足以下条件：

- 自反性（Reflexive）：对于非`null`的`x`来说，`x.equals(x)`必须返回`true`；
- 对称性（Symmetric）：对于非`null`的`x`和`y`来说，如果`x.equals(y)`为`true`，则`y.equals(x)`也必须为`true`；
- 传递性（Transitive）：对于非`null`的`x`、`y`和`z`来说，如果`x.equals(y)`为`true`，`y.equals(z)`也为`true`，那么`x.equals(z)`也必须为`true`；
- 一致性（Consistent）：对于非`null`的`x`和`y`来说，只要`x`和`y`状态不变，则`x.equals(y)`总是一致地返回`true`或者`false`；
- 对`null`的比较：即`x.equals(null)`永远返回`false`。

```java
public boolean equals(Object o) {
    if (o instanceof Person) {
        Person p = (Person) o;
        return this.name.equals(p.name) && this.age == p.age;
    }
    return false;
}
```

对于引用字段比较，我们使用`equals()`，对于基本类型字段的比较，我们使用`==`。

```java
public boolean equals(Object o) {
    if (o instanceof Person) {
        Person p = (Person) o;
        return Objects.equals(this.name, p.name) && this.age == p.age;
    }
    return false;
}
```

使用`Objects.equals()`比较两个引用类型是否相等的目的是省去了判断`null`的麻烦。两个引用类型都是`null`时它们也是相等的。



事实证明，两种写法如果前面的对象是null(而不只是String类型的引用为null)，调用equals方法都会报错(null无法调用任何方法）。

```java
Person nobody = null;
nobody.equals(null);  //报错NullPointerException
nobody.equals(nobody) //NullPointerException
System.out.println(null==null);//true
System.out.println(nobody==null);//true
```

```java
Person jack = new Person("jack", 12);
Person jack2 = new Person("jack",12);
System.out.println(jack==jack2); //false 两个不同的引用
System.out.println(jack.equals(jack2)); //true字面值相等
System.out.println(jack.equals(null)); //false;
```





使用`Objects.equals()`不会报错。

```java
Person nobody = null;
System.out.println(Objects.equals(null,null)); //true
System.out.println(Objects.equals(nobody,null));//true
System.out.println(Objects.equals(nobody,nobody)); //true
```

```java
Person nobody = new Person(null,12);
Person nobody2 = new Person(null,12);
System.out.println(nobody.equals(nobody2));//true
```

如果是这样就会报错

```java
return this.name.equals(p.name) && this.age == p.age;
```



#### Map

`Map<K, V>`是一种键-值映射表，当我们调用`put(K key, V value)`方法时，就把`key`和`value`做了映射并放入`Map`。当我们调用`V get(K key)`时，就可以通过`key`获取到对应的`value`。如果`key`不存在，则返回`null`。**和`List`类似，`Map`也是一个接口，**最常用的实现类是`HashMap`。

如果只是想查询某个`key`是否存在，可以调用`boolean containsKey(K key)`方法

> Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉

**遍历Map**

```java
//方法一：遍历key来遍历map
for (String key : map.keySet()) {
            Integer value = map.get(key);
            System.out.println(key + " = " + value);
        }
//方法二：遍历k,v实体来遍历
for (Map.Entry<String, Integer> entry : map.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key + " = " + value);
        }
```

**`HashMap`是如何通过`key`找到对应的`value`的：**

首先调用`key`对象的`hashCode()`方法，它返回一个`int`整数。如果两个`key`对象的hash值是相同的，那就在附近查找。

正确使用`Map`必须保证：

1. 作为`key`的对象必须正确覆写`equals()`方法，相等的两个`key`实例调用`equals()`必须返回`true`；
2. 作为`key`的对象还必须正确覆写`hashCode()`方法，且`hashCode()`方法要严格遵循以下规范：

- 如果两个对象相等，则两个对象的`hashCode()`必须相等；
- 如果两个对象不相等，则两个对象的`hashCode()`尽量不要相等。（存在相等的可能性）



**`HashMap`自动扩容**

添加超过一定数量的`key-value`时，`HashMap`会在**内部自动扩容**，每次扩容一倍。相应地，需要重新确定`hashCode()`计算的索引位置。由于扩容会导致重新分布已有的`key-value`，所以，**频繁扩容对`HashMap`的性能影响很大**。如果我们确定要使用一个容量为`10000`个`key-value`的`HashMap`，更好的方式是创建`HashMap`时就指定容量：

```Java
Map<String, Integer> map = new HashMap<>(10000);
```

虽然指定容量是`10000`，但`HashMap`内部的数组长度总是2^n，因此，实际数组长度被初始化为比`10000`大的`16384`（2^14）

更好的方式是指定容量为2的幂次。

```java
Map<String, Integer> map = new HashMap<>(2^14);
```



**自定义数据类型作为key时需要正确覆写`hashCode()`和`equals()`方法**

```java
public class Main {
    public static void main(String[] args)  {
        HashMap<Person, String> map = new HashMap<>();
        Person jack = new Person("jack", 19);
        Person marry = new Person("marry", 18);
        map.put(jack,"jack");
        map.put(marry,"marry");
        //遍历
        for(Person p:map.keySet()){
            String name = map.get(p);
            System.out.println(name);
        }

    }

}

class Person{
    private String name;
    private int age;
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public boolean equals(Object o){
        //因为String是引用类型，如果this和o同时为null的话，应该为相等，代码比较复杂
        return this.name.equals(((Person) o).name) && this.age==((Person) o).age;
        //以上方法可以省略判断this.name或者o.name为null的情况
    }
    @Override
    public int hashCode(){
        return age*11 + name.hashCode(); //String类型已经有了hashCode()
    }
}
```

如果此时`new`一个新的对象`jack2`作为`key`获取`value`，会得到和`jack`一样的结果，尽管他们不是同一个对象。

```java
Person jack2 = new Person("jack", 19); //和jack相同的name和age
System.out.println(map.get(jack2)); //jack 和key jack一样得到相同的value
```

注意到我们自定义的hashCode()方法，如果name为null,则会抛出异常，所以这里还需要处理这种情况，代码较为复杂，可以使用：

```java
@Override
public int hashCode(){
    return Objects.hash(name,age);
}
```

>  注意是`Objects`（来自`java.util`)，而不是`Object`(来自`java.lang`)。

`Objects`可以调用许多静态方法，例如

```java
equals(Object a, Object b);
hashCode(Object o);
compare(T a,T b, Comparator<? super T> c);
hash(Object... values);
isNull(Object obj);
nonNull(Object obj)
```

#### EnumMap

如果作为key的对象是`enum`类型，那么，还可以使用Java集合库提供的一种`EnumMap`，它在内部以一个非常紧凑的数组存储value，并且根据`enum`类型的key直接定位到内部数组的索引，并不需要计算`hashCode()`，不但效率最高，而且没有额外的空间浪费。

```java
public class Main {
    public static void main(String[] args)  {
        EnumMap<DayOfWeek, String> map = new EnumMap<DayOfWeek, String>(DayOfWeek.class);
        map.put(DayOfWeek.MONDAY,"星期一");
        map.put(DayOfWeek.TUESDAY,"星期二");
    }

}

enum DayOfWeek{
        MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY
}
```

#### TreeMap

我们已经知道，`HashMap`是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历`HashMap`的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。

还有一种`Map`，它在内部会对Key进行排序，这种`Map`就是`SortedMap`。注意到`SortedMap`是接口，它的实现类是`TreeMap`

使用`TreeMap`时，放入的Key必须实现`Comparable`接口。`String`、`Integer`这些类已经实现了`Comparable`接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。

如果作为Key的class没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个自定义排序算法

> 注意这里用到了匿名类：new classname(){...}

```java
  Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
            public int compare(Person p1, Person p2) {
                return p1.name.compareTo(p2.name);
            }
        });
```

> 注意到`Person`类并未覆写`equals()`和`hashCode()`，因为`TreeMap`不使用`equals()`和`hashCode()`

```java
Map<Student, Integer> map = new TreeMap<>(new Comparator<Student>() {
            public int compare(Student p1, Student p2) {
                if (p1.score == p2.score) {
                    return 0;
                }
                return p1.score > p2.score ? -1 : 1;
            }
        });
```

或者直接借助`Integer.compare(int, int)`也可以返回正确的比较结果

```java
public class Main {
    public static void main(String[] args)  {
        TreeMap<Person, Integer> map = new TreeMap<>(
                new Comparator<Person>() {
                    @Override
                    public int compare(Person o1, Person o2) {
                        if(o1.age==o2.age) return 0;
                        return o1.age<o2.age?-1:1;
                    }
                }
        );
        Person p1 = new Person("jack",19);
        Person p2 = new Person("marry",15);
        map.put(p1,p1.age);
        map.put(p2,p2.age);
        for(Person p: map.keySet()){
            System.out.println(p);
        }
        System.out.println(map.get(new Person("jack",19)));  //19
        System.out.println(map.get(new Person("jack",18)));  //null
    }
}


class Person{
    private String name;
    public int age;
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString(){
        return name + " " + age;
    }
}
```

#### Properties

配置文件的`Key-Value`一般都是`String`-`String`类型的，因此我们完全可以用`Map<String, String>`来表示它。

因为配置文件非常常用，所以Java集合库提供了一个`Properties`来表示一组“配置”。由于历史遗留原因，`Properties`内部本质上是一个`Hashtable`，但我们只需要用到`Properties`自身关于读写配置的接口。

```Python
# setting.properties #表示注释

last_open_file=/data/hello.txt
auto_save_interval=60
```



Java集合库提供的`Properties`用于读写配置文件`.properties`。`.properties`文件可以使用UTF-8编码。

可以从文件系统、`classpath`或其他任何地方读取`.properties`文件。

读写`Properties`时，注意仅使用`getProperty()`和`setProperty()`方法，不要调用继承而来的`get()`和`put()`等方法。

#### Set

`Set`用于存储不重复的元素集合，它主要提供以下几个方法：

- 将元素添加进`Set<E>`：`boolean add(E e)`
- 将元素从`Set<E>`删除：`boolean remove(Object e)`
- 判断是否包含元素：`boolean contains(Object e)`

最常用的`Set`实现类是`HashSet`，实际上，`HashSet`仅仅是对`HashMap`的一个简单封装

`Set`接口并不保证有序，而`SortedSet`接口则保证元素是有序的：

- `HashSet`是无序的，因为它实现了`Set`接口，并没有实现`SortedSet`接口；
- `TreeSet`是有序的，因为它实现了`SortedSet`接口。

因此：使用`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象。

另外：放入`Set`的元素和`Map`的key类似，都要正确实现`equals()`和`hashCode()`方法，否则该元素无法正确地放入`Set`。

#### Queue

在Java的标准库中，队列接口`Queue`定义了以下几个方法：

- `int size()`：获取队列长度；
- `boolean add(E)`/`boolean offer(E)`：添加元素到队尾；
- `E remove()`/`E poll()`：获取队首元素并从队列中删除；
- `E element()`/`E peek()`：获取队首元素但并不从队列中删除。

  前者会抛出异常，后者会返回false或者null

推荐使用：  `offer  poll  peek`  即可

> `LinkedList`即实现了`List`接口，又实现了`Queue`接口

```java
// 这是一个List:
List<String> list = new LinkedList<>();
// 这是一个Queue:
Queue<String> queue = new LinkedList<>();
```

**要避免把`null`添加到队列**,否则`poll peek`无法区分是没有获取到还是获取到了`null`。



#### Deque

这也是一个实现类。

`Deque`实现了一个双端队列（Double Ended Queue），它可以：

- 将元素添加到队尾或队首：`addLast()`/`offerLast()`/`addFirst()`/`offerFirst()`；
- 从队首／队尾获取元素并删除：`removeFirst()`/`pollFirst()`/`removeLast()`/`pollLast()`；
- 从队首／队尾获取元素但不删除：`getFirst()`/`peekFirst()`/`getLast()`/`peekLast()`；
- 总是调用`xxxFirst()`/`xxxLast()`以便与`Queue`的方法区分开；
- 避免把`null`添加到队列。

使用`Deque`，推荐总是明确调用`offerLast()`/`offerFirst()`或者`pollFirst()`/`pollLast()`方法。

`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。

`LinkedList`真是一个全能选手，它即是`List`，又是`Queue`，还是`Deque`。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。

```java
// 不推荐的写法:
LinkedList<String> d1 = new LinkedList<>();
d1.offerLast("z");
// 推荐的写法：
Deque<String> d2 = new LinkedList<>();
d2.offerLast("z");
```

#### PriorityQueue

优先队列：根据元素的优先级来获取元素，因此放入优先队列中的元素必须实现`Comparable`接口。

如果我们要放入的元素并没有实现`Comparable`接口怎么办？`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。

#### Stack

`Stack`只有入栈和出栈的操作：
- 把元素压栈：`push(E)`；
- 把栈顶的元素“弹出”：`pop()`；
- 取栈顶元素但不弹出：`peek()



> 注意：对于队列有`Queue`、`Deque`等接口，链表有`List`，集合有`Set`,字典有`Map`等接口，但是没有`Stack`这个接口

**为什么Java的集合类没有单独的`Stack`接口呢？**

因为有个遗留类名字就叫`Stack`，出于兼容性考虑，所以没办法创建`Stack`接口，只能用`Deque`接口来“模拟”一个`Stack`了。



#### Iterator

```java
List<String> list = List.of("Apple", "Orange", "Pear");
for (String s : list) {
    System.out.println(s);
}
```

> 注意：of方法在Java9之后才有。

实际上，Java编译器并不知道如何遍历`List`。上述代码能够编译通过，只是因为编译器把`for each`循环通过`Iterator`改写为了普通的`for`循环：

```java
for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
     String s = it.next();
     System.out.println(s);
}
```

使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。因为`Iterator`对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的`for each`循环自动转换为`Iterator`遍历。

如果我们自己编写了一个集合类，想要使用`for each`循环，只需满足以下条件：

- 集合类实现`Iterable`接口，该接口要求返回一个`Iterator`对象；
- 用`Iterator`对象迭代集合内部数据。



#### Collections

`Collections`提供了一系列方法来创建空集合：

- 创建空List：`List<T> emptyList()`
- 创建空Map：`Map<K, V> emptyMap()`
- 创建空Set：`Set<T> emptySet()`

要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。

`Collections`提供了一系列方法来创建一个单元素集合：

- 创建一个元素的List：`List<T> singletonList(T o)`
- 创建一个元素的Map：`Map<K, V> singletonMap(K key, V value)`
- 创建一个元素的Set：`Set<T> singleton(T o)`

要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。

`Collections`可以对`List`进行排序。因为排序会直接修改`List`元素的位置，因此必须传入可变`List`：`Collections.sort(list);`

`Collections.shuffle(list);`



`Collections`还提供了一组方法把可变集合封装成不可变集合：

- 封装成不可变List：`List<T> unmodifiableList(List<? extends T> list)`
- 封装成不可变Set：`Set<T> unmodifiableSet(Set<? extends T> set)`
- 封装成不可变Map：`Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`

但是，继续对原始的可变`List`进行增删是可以的，并且，会直接影响到封装后的“不可变”`List`：

```java
List<String> mutable = new ArrayList<>();
mutable.add("apple");
mutable.add("pear");
// 变为不可变集合:
List<String> immutable = Collections.unmodifiableList(mutable);
mutable.add("orange");
System.out.println(immutable); //有orange
```

因此，如果我们希望把一个可变`List`封装成不可变`List`，那么，返回不可变`List`后，最好立刻扔掉可变`List`的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”`List`变化了

```java
mutable = null;
```

