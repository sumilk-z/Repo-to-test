### IO

- `Input`

  从外部读数据到内存，例如从磁盘、网络读取数据到内存。

- `Output`

  把数据从内存输出到外部，例如把数据从内存写入文件，或者输出到网络等。

- `InputStream`和`OutputStream`

​		`IO`流以字节`byte`为最小单位，因此也称为**字节流**。

- `Reader`和`Writer`

​	  如果我们需要读写的是字符，以最小单位为`char`来进行读写，称为**字符流**。

`    Java`用`Reader`和`Writer`表示字符流，本质上是一个能自动编码和解码的`InputStream`和`OutputStream`。

- 同步和异步

  同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。

  而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。

Java标准库的包`java.io`提供了同步IO，而`java.nio`则是异步IO。`InputStream`、`OutputStream`、`Reader`和`Writer`都是同步IO的抽象类，对应的具体实现类，以文件为例，有`FileInputStream`、`FileOutputStream`、`FileReader`和`FileWriter`。

Java的`String`和`char`在内存中总是以Unicode编码表示。

#### File

Java的标准库`java.io`提供了`File`对象来操作文件和目录。`File`对象既可以表示文件，也可以表示目录。

> 注意Windows平台使用`\`作为路径分隔符，在Java字符串中需要用`\\`表示一个`\`。Linux平台使用`/`作为路径分隔符;

#####  **构建一个`File`对象**

构造一个`File`对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个`File`对象，并不会导致任何磁盘操作。只有当我们调用`File`对象的某些方法的时候，才真正进行磁盘操作。而此时如果文件或者目录不存在则会报错。

```java
File f = new File("C:\\Windows\\notepad.exe"); //传入绝对路径
File f = new File("/usr/bin/javac"); //Linux操作系统用/作为路劲分隔符。 /斜杠 \反斜杠
//也可以使用相对路径，假设当前目录是C:\Docs
File f = new File("sub\\javac"); //绝对路径是 C:\Docs\sub\javac
File f = new File(".\\sub\\javac"); //绝对路径是 C:\Docs\sub\javac
File f = new File("..\\sub\\javac"); //绝对路径是 C:\sub\javac
```

或者也可以传入一个文件目录，因为File对象不仅可以操作文件还可以操作文件目录。

##### File对象的方法

首先可以判断该对象是一个文件还是目录：

```java
File file = new File(".."); // .表示当前目录，..表示上层目录
System.out.println(file.isFile()); //false
System.out.println(file.isDirectory()); //true
```

其次，可以返回文件/目录的路径，有三种方法：

```java
//相对路径
System.out.println(file.getPath()); //.. 
//绝对路径
System.out.println(file.getAbsolutePath()); // D:\AllProjects\JavaProject\j2se\..
//规范路: 就是把.和..转换成标准的绝对路径后的路径
System.out.println(file.getCanonicalPath()); // D:\AllProjects\JavaProject
```

另外，可以根据`File`对象创建文件，并且调用相应的方法：

- `boolean canRead()`：是否可读；
- `boolean canWrite()`：是否可写；
- `boolean canExecute()`：是否可执行；
- `long length()`：文件字节大小。

```java
File file = new File(".\\test.txt");
if(file.createNewFile()){
    System.out.println(file.getName()); //test.txt
    System.out.println(file.canRead()); //true
    System.out.println(file.canWrite()); //true
    System.out.println(file.canExecute()); //true
    System.out.println(file.length());//0
}
file.deleteOnExit();//JVM退出时删除
//boolean delete = file.delete();
```

可以删除文件：

```java
file.deleteOnExit();//JVM退出时删除，或者
file.delete();//会返回是否删除成功
```

**操作目录**

和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：

- `boolean mkdir()`：创建当前File对象表示的目录；
- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；
- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功。



当File对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。

```java
public class Main {
    public static void main(String[] args) throws IOException {
        File file = new File("D:\\Software");
        File[] files = file.listFiles(); //列出所有文件和子目录
        printFiles(files);
        File[] files2 = file.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".exe");//返回true表示接受该文件
            }
        });
        printFiles(files2);
    }
    //打印文件的方法
    public static void printFiles(File[] files){
        System.out.println("--------------------");
        if(files!=null){
            for(File f:files){
                System.out.println(f);
            }
        }
        System.out.println("--------------------");
    }
}
```

输出

```tex
--------------------
D:\Software\.JDKs.intellij
D:\Software\7-Zip
...省略
D:\Software\磁盘空间占用定位器.exe
D:\Software\稻壳阅读器安装程序.exe
D:\Software\超星学习通
--------------------
--------------------
D:\Software\7z2107-x64.exe
...省略
D:\Software\Zoom.exe
D:\Software\磁盘空间占用定位器.exe
D:\Software\稻壳阅读器安装程序.exe
--------------------
```



##### Path

Java标准库还提供了一个`Path`对象，它位于`java.nio.file`包。`Path`对象和`File`对象类似，但操作更加简单.

如果需要对目录进行复杂的拼接、遍历等操作，使用`Path`对象更方便。



#### InputStream

`InputStream`就是Java标准库提供的最基本的输入流。它位于`java.io`这个包里。`java.io`包提供了所有同步IO的功能。

`InputStream`并不是一个接口，而是一个抽象类，它是所有输入流的超类。

这个抽象类定义的一个最重要的方法就是`int read()`

```java
public abstract int read() throws IOException;
```

这个方法会读取输入流的下一个字节，并返回字节表示的`int`值（0~255）。如果已读到末尾，返回`-1`表示不能继续读取了。

##### **FileInputStream**

`FileInputStream`是`InputStream`的一个子类。顾名思义，`FileInputStream`就是从文件流中读取数据。

```java
public static void readFile() throws IOException {
    FileInputStream input = new FileInputStream(".\\test.txt");
    for(;;){
        int n = input.read();
        if(n==-1) break;
        System.out.print(n);
        System.out.print(" ");
    }
    input.close(); //关闭输入流
}
```

输出

```java
97 32 98 32 99 32 49 32 50 32 51 
```

有一个潜在的问题：如果读取过程中发生了IO错误，`InputStream`就没法正确地关闭，资源也就没法及时释放。

需要用`try ... finally`来保证`InputStream`在无论是否发生IO错误的时候都能够正确地关闭：

```java
try {
    FileInputStream input = new FileInputStream(".\\test.txt");
    int n;
    while ((n = input.read()) != -1) { // 利用while同时读取并判断
        System.out.println(n);
    }
} finally {
    if (input != null) { input.close(); }
}
```

用`try ... finally`来编写上述代码会感觉比较复杂，更好的写法是利用**Java 7引入的新的`try(resource)`的语法**，只需要编写`try`语句，让编译器自动为我们关闭资源。

```java
public void readFile() throws IOException {
    try (InputStream input = new FileInputStream("..\\test.txt")) {
        int n;
        while ((n = input.read()) != -1) {
            System.out.println(n);
        }
    } // 编译器在此自动为我们写入finally并调用close()
}
```

区别是：

```java
try{
    ...
} finally{
    ...
}
和
try(resource){
    ...
}//auto close the resource
```

实际上，编译器并不会特别地为`InputStream`加上自动关闭。编译器只看`try(resource = ...)`中的对象是否实现了`java.lang.AutoCloseable`接口，如果实现了，就自动加上`finally`语句并调用`close()`方法。`InputStream`和`OutputStream`都实现了这个接口，因此，都可以用在`try(resource)`中。

> 同时操作多个`AutoCloseable`资源时，在`try(resource) { ... }`语句中可以同时写出多个资源，用`;`隔开。

```java
// 读取input.txt，写入output.txt:
try (InputStream input = new FileInputStream("input.txt");
     OutputStream output = new FileOutputStream("output.txt"))
{
    input.transferTo(output); 
}
```

---



##### **ByteArrayInputStream**

`ByteArrayInputStream`可以在内存中模拟一个`InputStream`

```java
byte[] data = { 72, 101, 108, 108, 111, 33 };
InputStream input = new ByteArrayInputStream(data);
```

`ByteArrayInputStream`实际上是把一个`byte[]`数组在内存中变成一个`InputStream`

例如：需要在本地新建一个文件。C:\\test\\README.txt

```java
public static void main(String[] args) throws IOException {
    String s;
    try (InputStream input = new FileInputStream("C:\\test\\README.txt")) {
        s = readAsString(input);
    }
    System.out.println(s);
}
//读取输入流并输出为字符串
public static String readAsString(InputStream input) throws IOException {
    int n;
    StringBuilder sb = new StringBuilder();
    while ((n = input.read()) != -1) {
        sb.append((char) n);
    }
    return sb.toString();
}
```

但是其实可以模拟一个输入流来进行测试：

```java
byte[] data = { 72, 101, 108, 108, 111, 33 };
try (InputStream input = new ByteArrayInputStream(data)) {
    String s = readAsString(input);
    System.out.println(s);
}
```

---

---



#### OutputStream

和`InputStream`类似，`OutputStream`也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是`void write(int b)`

```java
public abstract void write(int b) throws IOException;
```

这个方法会写入一个字节到输出流。要注意的是，虽然传入的是`int`参数，但只会写入一个字节，即只写入`int`最低8位表示字节的部分（相当于`b & 0xff`）

`OutputStream`还提供了一个`flush()`方法，它的目的是将缓冲区的内容真正输出到目的地。

**为什么要有`flush()`？**

因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个`byte[]`数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以`OutputStream`有个`flush()`方法，能强制把缓冲区内容输出。

通常情况下，我们不需要调用这个`flush()`方法，因为缓冲区写满了`OutputStream`会自动调用它，并且，在调用`close()`方法关闭`OutputStream`之前，也会自动调用`flush()`方法。

但是某些情况下需要手动调用：例如聊天软件每次发送一条信息时就得刷新发送，不能堆积延迟。

---



##### **FileOutputStream**

```Java
public void writeFile() throws IOException {
    OutputStream output = new FileOutputStream("out/readme.txt");
    output.write(72); // H
    output.write(101); // e
    output.write(108); // l
    output.write(108); // l
    output.write(111); // o
    output.close();
}
```

可以用`OutputStream`提供的重载方法`void write(byte[])`一次性写入多个字节。

```Java
public void writeFile() throws IOException {
    try (OutputStream output = new FileOutputStream("out/readme.txt")) {
        output.write("Hello".getBytes("UTF-8")); // Hello
    } // 编译器在此自动为我们写入finally并调用close()
}
```

和`InputStream`一样，`OutputStream`的`write()`方法也是阻塞的；

---



##### **ByteArrayOutputStream**

`ByteArrayOutputStream`可以在内存中模拟一个`OutputStream`：

```java
public static void main(String[] args) throws IOException {
    byte[] data;
    try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {
        output.write("Hello ".getBytes("UTF-8"));
        output.write("world!".getBytes("UTF-8"));
        data = output.toByteArray();
    }
    System.out.println(new String(data, "UTF-8"));
}
```

`ByteArrayOutputStream`实际上是把一个`byte[]`数组在内存中变成一个`OutputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`OutputStream`。



#### Filter模式

```ascii
┌─────────────────────────┐
│GZIPInputStream          │
│┌───────────────────────┐│
││BufferedFileInputStream││
││┌─────────────────────┐││
│││   FileInputStream   │││
││└─────────────────────┘││
│└───────────────────────┘│
└─────────────────────────┘
```

上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：

Java的IO标准库使用Filter模式为`InputStream`和`OutputStream`增加功能：

- 可以把一个`InputStream`和任意个`FilterInputStream`组合；
- 可以把一个`OutputStream`和任意个`FilterOutputStream`组合。

Filter模式可以在运行期动态增加功能（又称Decorator模式）。