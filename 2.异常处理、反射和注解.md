### 异常处理

#### Java的异常

Java的异常是`class`，它的继承关系如下：

![image-20220706184223080](D:\Document\研究生\Java学习\Java基础\异常处理.assets\image-20220706184223080.png)

从继承关系可知：`Throwable`是异常体系的根，它继承自`Object`。`Throwable`有两个体系：`Error`和`Exception`，`Error`表示严重的错误，程序对此一般无能为力，例如：

- `OutOfMemoryError`：内存耗尽
- `NoClassDefFoundError`：无法加载某个Class
- `StackOverflowError`：栈溢出

而`Exception`则是运行时的错误，它可以被捕获并处理。

某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：

- `NumberFormatException`：数值类型的格式错误
- `FileNotFoundException`：未找到文件
- `SocketException`：读取网络失败

还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：

- `NullPointerException`：对某个`null`的对象调用方法或字段
- `IndexOutOfBoundsException`：数组索引越界

`Exception`又分为两大类：

1. `RuntimeException`以及它的子类；
2. 非`RuntimeException`（包括`IOException`、`ReflectiveOperationException`等等）

**Java规定：**

- 必须捕获的异常，包括`Exception`及其子类，但不包括`RuntimeException`及其子类，这种类型的异常称为`Checked Exception`。

- **不需要捕获的异常，包括`Error`及其子类，`RuntimeException`及其子类**。

  

  所有异常都可以调用`printStackTrace()`方法打印异常栈，这是一个简单有用的快速打印异常的方法。



捕获异常可以在调用的地方捕获，也可以在更高一层捕获，但是`main()`函数是捕获异常的最后机会。

**使用异常举例**

1.没有捕获异常

```java
public class Main {
    public static void main(String[] args) {
        byte[] bs = toGBK("中文");
        System.out.println(Arrays.toString(bs));

    }
    public static byte[] toGBK(String s){
        return s.getBytes("GBK");
    }
}
//输出: java: 未报告的异常错误java.io.UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出
```

这是因为`String.getBytes(String)`方法定义是：

```java
public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    ...
}
```

2.继续抛出异常或者捕获异常

在方法定义的时候，使用`throws Xxx`表示该方法可能抛出的异常类型。**调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。**

**但是也可以不捕获它，而是继续抛出，但是必须在某一层捕获，main是最后的捕获机会**

```java
 static byte[] toGBK(String s) throws UnsupportedEncodingException {
        return s.getBytes("GBK");
 }
```

必须在上层捕获

```java
public class Main {
    public static void main(String[] args) {
        //此处必须捕获该异常
        try{
            byte[] bs = toGBK("中文");
            System.out.println(Arrays.toString(bs));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

    }
    //调用的时候没有捕获该异常，而是选择继续抛出
    public static byte[] toGBK(String s) throws UnsupportedEncodingException{
        return s.getBytes("GBK");
    }
}
```

==**可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。**==

3.终极方法：main也抛出异常 `throws Exception`

```java
public class Main {
    public static void main(String[] args) throws Exception{
        byte[] bs = toGBK("中文");
        System.out.println(Arrays.toString(bs));
    }
    public static byte[] toGBK(String s) throws UnsupportedEncodingException{
        return s.getBytes("GBK");
    }
}

```

`main()`函数没有选择捕获异常，而是继续抛出异常`throws Exception`，这样一旦出现异常程序就停止运行。

换一种说法应该是**声明抛出异常**：`main()`方法声明了可能抛出`Exception`，也就声明了可能抛出所有的`Exception`

**小结**

Java使用异常来表示错误，并通过`try ... catch`捕获异常；

Java的异常是`class`，并且从`Throwable`继承；

`Error`是无需捕获的严重错误，`Exception`是应该捕获的可处理的错误；

`RuntimeException`无需强制捕获，非`RuntimeException`（Checked Exception）需强制捕获，或者用`throws`声明；

不推荐捕获了异常但不进行任何处理

#### 捕获异常

使用`try...catch...finally`来捕获异常，其中`finally`不是必须的。

```java
public static void main(String[] args) {
    try {
        process1();
        process2();
        process3();
    } catch (UnsupportedEncodingException e) { //子类必须写在前面，否则永远都无法捕获到该异常
        System.out.println("Bad encoding");
    } catch (IOException e) {
        System.out.println("IO error");
    }
}
```

如果没有发生异常，就正常执行`try { ... }`语句块，然后执行`finally`。如果发生了异常，就中断执行`try { ... }`语句块，然后跳转执行匹配的`catch`语句块，最后执行`finally`。

> 总之finally语句最后一定会执行的。



**捕获多种异常**

如果某些异常的处理逻辑相同，但是异常本身**不存在继承关系**，那么就可以使用`|`合并在一起，因为处理逻辑相同。

```java
public static void main(String[] args) {
    try {
        process1();
        process2();
        process3();
    } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException
        System.out.println("Bad input"); //这两种异常不存在继承关系，可以写在一起，因为他们的处理逻辑都相同
    } catch (Exception e) {
        System.out.println("Unknown error");
    }
}
```

> 注意这里是单竖杠，而不是”||“或，应该是表示拼接的意思。

如下所示，谁先执行就捕获谁的异常，因为发生异常之后程序就会中断执行。

```java
public class Main {
    public static void main(String[] args) {
        try{
            process2();
            process1();

        } catch (IOException | NumberFormatException e) {
            e.printStackTrace();
        }
    }
    public static void process1() throws IOException { //这里函数定义的时候就声明了可能会抛出异常
        System.out.println("process1");
        throw new IOException();
    }
    public static void process2(){
        System.out.println("process2");
        throw new NumberFormatException();
    }
}
```



#### 抛出异常

抛出异常分两步：

1. 创建某个`Exception`的实例；
2. 用`throw`语句抛出。

或者直接一步到位，如下所示。

```java
public static int parseInt(String s, int radix) throws NumberFormatException {
    if (s == null) {
        throw new NumberFormatException("null");
    }
    ...
}
```

如果一个方法捕获了某个异常后，又在`catch`子句中抛出新的异常，就相当于把抛出的异常类型“转换”了

```java
void process1(String s) {
    try {
        process2();
    } catch (NullPointerException e) {
        throw new IllegalArgumentException(); //捕获异常又抛出新的异常
    }
}

void process2(String s) {
    if (s==null) {
        throw new NullPointerException();
    }
}
```

`process1`执行的时候捕捉到`process2`抛出的`NullPointerException`异常，然后抛出新的异常`IllegalArgumentException`，相当于对异常转换了。输出结果如下：

```java
java.lang.IllegalAccessException
	at Main.java.Main.process1(Main.java:19)
	at Main.java.Main.main(Main.java:10)
```

新的异常**丢失了原始异常信息**，我们已经看不到原始异常`NullPointerException`的信息了,为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息。

```java
public class Main {
    public static void main(String[] args) {
        String s = null;
        process1(s);
    }
    public static void process1(String s) {
        try{
            process2(s);
        } catch (NullPointerException e) {
            throw new IllegalArgumentException(e); //将捕获到的异常传入新的异常中
        }
    }
    public static void process2(String s){
        if(s==null){
            throw new NullPointerException();
        }
    }
}
```

可以看到报了两种异常`Caused by: java.lang.NullPointerException`

```java
Exception in thread "main" java.lang.IllegalArgumentException: java.lang.NullPointerException
	at Main.java.Main.process1(Main.java:14)
	at Main.java.Main.main(Main.java:8)
Caused by: java.lang.NullPointerException
	at Main.java.Main.process2(Main.java:19)
	at Main.java.Main.process1(Main.java:12)
```

对于有`finally`的执行顺序：先执行`try`,然后执行`catch`中的内容，然后执行`finally`,最后再抛出`catch`中捕获的异常。

如果`finally`也有异常抛出，则之前`catch`中的异常就无法抛出，需要记录下来。(这种情况一般不常见)

#### 自定义异常

一个常见的做法是自定义一个`BaseException`作为“根异常”，然后，派生出各种业务类型的异常。

`BaseException`需要从一个适合的`Exception`派生，通常建议从`RuntimeException`派生：

```java
public class BaseException extends RuntimeException{
    
}
```

其他业务类型的异常就可以从`BaseException`派生：

```java
public class UserNotFoundException extends BaseException{
    
}
public class LoginFailedException extends BaseException{
    
}
```

#### NullPointerException

如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`，这个异常通常是**由JVM抛出的**.

`NullPointerException`是一种代码逻辑错误，遇到`NullPointerException`，遵循原则是早暴露，早修复，不能`catch`之后不处理。

#### 使用断言

实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解`JUnit`的使用。

断言是一种调试方式，断言失败会抛出`AssertionError`，只能在开发和测试阶段启用断言；

对可恢复的错误不能使用断言，而应该抛出异常；

断言很少被使用，更好的方法是编写单元测试。

```java
assert x>=0 : "x must >= 0";
```

> 断言失败时会抛出AssertionError导致程序退出，因此断言不能用于可恢复的程序错误，只应该用于开发和测试阶段，相当于断点。

JVM默认关闭断言指令，即遇到`assert`语句就自动忽略了，不执行，需要在命令行开启`-ea`或`enableassertions`

```
java -ea Test
Exception in thread "main" java.lang.AssertionError: s==null
        at Test.main(Test.java:4)
```



#### 使用JDK Logging

Java标准库内置了日志包`java.util.logging`，我们可以直接用

Java标准库内置的Logging使用并不是非常广泛

使用示例

```java
import java.util.logging.Logger;

public class Test {
    public static void main(String[] args) {
        Logger logger = Logger.getGlobal();
        logger.info("start process...");
        logger.warning("memory is running out...");
        logger.fine("ignored");
        logger.severe("process will be terminated...");
    }
}

```

输出结果

```java
七月 08, 2022 8:49:39 上午 Test main
信息: start process...
七月 08, 2022 8:49:39 上午 Test main
警告: memory is running out...
七月 08, 2022 8:49:39 上午 Test main
严重: process will be terminated...

Process finished with exit code 0
```



```java
public class Test {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(Test.class.getName());
        logger.info("Start Process...");
        try{
            " ".getBytes("invalidCharsetName");
        }catch (UnsupportedEncodingException e){
            logger.warning("invalid encoding charset name."); //打印错误信息
        }
        logger.info("Process End.");
    }
}
```

```java
七月 08, 2022 8:55:58 上午 Test main
信息: Start Process...
七月 08, 2022 8:55:58 上午 Test main
警告: invalid encoding charset name. //错误信息警告
七月 08, 2022 8:55:58 上午 Test main
信息: Process End.
```



#### 使用Commons Logging

Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。

> Commons Logging是一个第三方提供的库，所以，必须先把它[下载](https://commons.apache.org/proper/commons-logging/download_logging.cgi)下来。下载后，解压，找到`commons-logging-1.2.jar`这个文件，再把Java源码`Main.java`放到一个目录下



```java
静态方法中使用
    static final Log log = LogFactory.getLog(Main.class);
实例方法中使用
    protected final Log log = LogFactory.getLog(getClass());
```



#### 使用Log4j

在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入`classpath`，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。

#### 使用SLF4J和Logback

SLF4J和Logback可以取代Commons Logging和Log4j





### 反射

反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。

#### Class类

`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。

每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。注意：**这里的`Class`类型是一个名叫`Class`的`class`。**

```java
public final class Class{
    private Class(){}
}
```

> 有一个名叫Class的class，普通的class都是这个Class的实例。

以`String`类为例，当JVM加载`String`类时，它首先读取`String.class`文件到内存，然后，为`String`类创建一个`Class`实例并关联起来

```java
Class String = new Class(); // 创建一个名为String的Class实例
```

`Class`类的构造方法是`private`，只有JVM能创建`Class`实例，我们自己的Java程序是无法创建`Class`实例的.

一个`Class`实例包含了该`class`的所有信息。

由于JVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。

这种**通过`Class`实例获取`class`信息的方法称为反射（Reflection）。**

如何获取一个`class`的`Class`实例？有三个方法：

- 通过一个`class`的静态变量`class`获取

  ```java
  Class cls = String.class;
  ```

- 如果有一个实例(Class类的实例）变量（Class类的实例的实例），可以通过实例变量提供的`getClass()`方法获取

  ```java
  String s = "hello";
  Class cls = s.getClass();
  ```

- 如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取

  ```java
  Class cls = Class.forName("java.lang.String");
  ```

  因为`Class`实例在JVM中是唯一的，所以，上述方法获取的`Class`实例是同一个实例。可以用`==`比较两个`Class`实例。

  > Class实例在JVM中是唯一的：例如String是Class的一个实例，只有一个Sting类型。 而String又可以生成许多不同的实例，例如”hello", "hi",是不唯一的。



```java
public static void main(String[] args) throws ClassNotFoundException {
    String s = "hello";
    Class aClass = s.getClass();
    System.out.println(aClass); //class java.lang.String 实际上调用了aClass.class
    System.out.println(String.class);//class java.lang.String
    System.out.println(Class.forName("java.lang.String"));//class java.lang.String
    //------------------比较同一个实例---------------------
    System.out.println(String.class == Class.forName("java.lang.String")); //true
}
```



**从`Class`实例获取基本信息**

```java

public class Test {
    public static void main(String[] args) throws ClassNotFoundException {
//        printClassInfo(String.class);
        MyClass instance = new MyClass("myClassInstance");
        Class cls = instance.getClass();//从实例获取class,或者
        // Class cls = MyClass.class //静态变量
        // Class.forName("MyClass")
        printClassInfo(cls);
    }
    public static void printClassInfo(Class cls){
        System.out.println("Class name: "+cls.getName());
        System.out.println("Simple name: "+cls.getSimpleName());
        if(cls.getPackage()!=null){
            System.out.println("Package name: "+cls.getPackage().getName());
        }
        System.out.println("is interface: "+cls.isInterface());
        System.out.println("is enum: "+cls.isEnum());
        System.out.println("is array: "+cls.isArray());
        System.out.println("is primitive: "+cls.isPrimitive());
    }


}
//自定义的class
class MyClass{
    private String name;
    public MyClass(String name){
        this.name = name;
    }
}

```

**注意到`String[]`也是一种class**

```java
printClassInfo(String[].class);
Class name: [Ljava.lang.String; //类名比较奇怪
Simple name: String[]
is array: true //属于数组
```

**基本数据类型也是Class实例**

```java
printClassInfo(int.class);
Class name: int
Simple name: int
is primitive: true //属于基本类型
```

> 动态加载：JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。

利用JVM动态加载`class`的特性，我们才能在运行期根据条件加载不同的实现类。

**小结**

- JVM为每个加载的`class`及`interface`创建了对应的`Class`实例来保存`class`及`interface`的所有信息；

- 获取一个`class`对应的`Class`实例后，就可以获取该`class`的所有信息；

- 通过Class实例获取`class`信息的方法称为反射（Reflection）；

- JVM总是动态加载`class`，可以在运行期根据条件来控制加载class。



#### 访问字段

`Class`类提供了以下几个方法来获取字段：

- `Field getField(name)`：根据字段名获取某个public的field（包括父类）
- `Field getDeclaredField(name)`：根据字段名获取当前类的某个field（不包括父类）
- `Field[] getFields()`：获取所有public的field（包括父类）
- `Field[] getDeclaredFields()`：获取当前类的所有field（不包括父类）

获取字段举例：注意到父类的`private`字段无法获取。当前类的`private`字段需要`getDeclaredField()`方法才能获取；以及`getField()`可以获取当前类以及父类的`Public`字段。（子类可以访问父类的`private`字段，但是不属于自己；父类的`public`字段自动遗传给自己）

```java
public class Main {
    public static void main(String[] args) throws NoSuchFieldException {
        Student student = new Student();
        Class cls = student.getClass();
        Field score = cls.getField("score");
        Field name = cls.getField("name");
//        Field grade = cls.getField("grade"); //报错，private字段不能用getField
        Field grade = cls.getDeclaredField("grade");
        
    }
}

class Person{
    public String name;
}

class Student extends Person{
    public int score;
    private int grade;
}
```



#### **Field类**

一个`Class`对象包含了这个类的所有信息，然后根据`Class`对象又可以获取到字段对象、方法对象、构造函数对象、注解对象等。

一个`Field`对象包含了一个字段的所有信息：

- `getName()`：返回字段名称，例如，`"name"`；
- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；
- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。

```java
System.out.println(score.getName()); //获取字段名：score
System.out.println(score.get(student));//获取字段值：0 初始化为0，另外需要传入对象。
System.out.println(score.getType()); //获取字段类型： int
```

> 注意：如果访问的字段是private的，则会报错，需要先设置`Field.setAccessible(true)`，这样就可以访问了。

```java
 Field grade = cls.getDeclaredField("grade"); // grade 是 private 字段
Object o = grade.get(student);
System.out.println(o);
----------------------------------------------------------------------
Class Main.java.Main can not access a member of class Main.java.Student with modifiers "private"
```

无法访问`grade`字段的值，因为它是`private`修饰的。

```java
grade.setAccessible(true); //设置可以访问
//得到结果： 0 因为什么都没做，int类型初始化为0
```

既然可以访问字段的值，也可以对字段的值进行修改

```java
grade.set(student,100); // 格式为 Field.set(Object o, value); 第一个参数是要修改字段的实例，第二个参数是要修改的值。
System.out.println(grade.get(student)); //100
```



**问题：如果使用反射可以获取`private`字段的值，那么类的封装还有什么意义？**

答案是正常情况下，我们总是通过`p.name`来访问`Person`的`name`字段，编译器会根据`public`、`protected`和`private`决定是否允许访问字段，这样就达到了数据封装的目的。

而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。

此外，`setAccessible(true)`可能会失败。如果JVM运行期存在`SecurityManager`，那么它会根据规则进行检查，有可能阻止`setAccessible(true)`。例如，某个`SecurityManager`可能不允许对`java`和`javax`开头的`package`的类调用`setAccessible(true)`，这样可以保证JVM核心库的安全。

#### 调用方法

既然可以通过`Class`来获取字段`Field`，同样也能通过`Class`来获取方法`Method`; 获取方法如下：

- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）
- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）
- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）

> 上面第一个和第二个方法的第二个参数`Class...`表示要获取的方法的形参，因为方法可能是重载的，所以需要这个参数来进行区分。第三个和第四个是获取所有方法，不需要参数，加了`Declared`的表示能获取非public方法，但是不包括父类。

**应用举例**

```java
package  Main.java;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException {
        Class cls = Student.class; //获取Student的Class
        Method getName = cls.getMethod("getName"); //获取父类的public方法
        Method getScore = cls.getMethod("getScore"); //获取当前类的public方法，无参数
        Method setScore = cls.getMethod("setScore", int.class); //获取当前类的public方法，带参数
        Method getGrade = cls.getDeclaredMethod("getGrade"); //获取当前类的private方法
        Method setGrade = cls.getDeclaredMethod("setGrade", int.class);//获取当前类的private方法，带参数

    }

}

class Person{
    public String name;
    public String getName(){
        return this.name;
    }
    private void setName(String name){
        this.name = name;
    }
}

class Student extends Person{
    public int score;
    private int grade;
    public int getScore(){
        return this.score;
    }
    public void setScore(int score){
        this.score = score;
    }
    private int getGrade(){
        return  this.grade;
    }
    private void setGrade(int grade){
        this.grade = grade;
    }
}
```

> 父类的`private`字段、方法都无法获取。当前类的`private`字段、方法必须用`getDeclaredField()`、`getDeclaredMethod()`

#### Method类

一个`Method`对象包含一个方法的所有信息：

- `getName()`：返回方法名称，例如：`"getScore"`；
- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；
- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；
- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。

**如何调用Method对象?**

对`Method`实例调用`invoke`就相当于调用该方法，`invoke`的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。

例如，上面获取到的`Method`对象`setScore`

```java
Method setScore = cls.getMethod("setScore", int.class); //获取当前类的public方法，带参数
```

调用方式：

```java
Student student = new Student(); //一个Student对象实例
setScore.invoke(student,100); //没有返回值
```

> 注意：如果是调用非public方法，同样需要设置`Method.setAccessible(true)`才能允许其调用

```java
Method setGrade = cls.getDeclaredMethod("setGrade", int.class);//获取当前类的private方法，带参数
setGrade.setAccessible(true);
setGrade(student,100); //没有返回值
```



**一个存在函数重载的例子**

我们以`String`类为例，先获取`String`的`Class`对象，然后获取其方法`subString`的`Method`对象，注意到该方法具有重载现象

```java
String subString(int beg); //截取从beg到字符末尾的字符串
String subString(int beg,int end); //截取从beg到end的字符串，但不包括end
```



```java
public class Main {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        String s = "hello";
        Class cls = s.getClass();
        //String subString(int beg);
        Method substring = cls.getMethod("substring", int.class);
        String s1 = (String) substring.invoke(s, 1);
        System.out.println(s1);//ello
		//String subString(int beg, int end); 多个参数，传入Class数组
        Method substring1 = cls.getMethod("substring", new Class[]{int.class, int.class}); 
        final String s2 = (String) substring1.invoke(s, 1,4);
        System.out.println(s2); //ell
    }

}
```

> 注意这个：`Method substring1 = cls.getMethod("substring", new Class[]{int.class, int.class}); `
>
> 也可以是`Method method= cls.getMethod("method", new Class[]{int.class, String.class}); `
>
> 甚至是自定义的数据类型`Method method= cls.getMethod("method", new Class[]{Person.class, int.class}); `

#### 调用静态方法

调用静态方法，同样的道理，先获取到方法的`Method`，对象，然后执行`invoke`方法即可，但是区别在于静态方法不需要传入对象实例，因此第一个参数是`null`

```java
 String c = String.valueOf('c'); //valueOf是String的静态方法
Method valueOf = String.class.getMethod("valueOf", char.class);
String c1 = (String)valueOf.invoke(null, 'c'); //不需要传入实例对象，第一个参数为null即可
System.out.println(c); // "c"
System.out.println(c1); // "c"
```

#### 反射中多态依旧

```java
class Person{
    public void hello(){
        System.out.println("hello person");
    }
}

class Student extends Person{
    public void hello(){
        System.out.println("hello student");
    }
}
```

然后获取方法，并传入对象执行

```java
Method hello = Person.class.getMethod("hello");
hello.invoke(new Student()); //hello student
```

实际上相当于

```java
Person p = new Student();
p.hello();
```

**使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。**



#### 调用构造方法

如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：

```java
Person p = Person.class.newInstance();
String s = String.class.newInstance();
```

调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。

`Constructor`对象封装了构造方法的所有信息；

通过`Class`实例的方法可以获取`Constructor`实例：`getConstructor()`，`getConstructors()`，`getDeclaredConstructor()`，`getDeclaredConstructors()`；

通过`Constructor`实例可以创建一个实例对象：`newInstance(Object... parameters)`； 通过设置`setAccessible(true)`来访问非`public`构造方法。

```java
Constructor<String> constructor = String.class.getConstructor(String.class); //注意要传入参数。
String abc = constructor.newInstance("abc");
```

**利用反射调用构造函数的例子**

```java
public class Main {
    public static void main(String[] args) {
        Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class);
        Person jack = constructor.newInstance("jack", 23);
        System.out.println(jack); //name: jack age: 23
    }
}

class Person{
    public String name;
    public int age;
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString(){
        return "name: "+name + " age: "+age;
    }
}
```

**注意到**

```java
Constructor<Person> constructor = Person.class.getConstructor(String.class, int.class);
```

传入的参数不需要构造`Class`数组，元数据类型也不用写成包装类型`Integer.class`，因为基本数据类型也有`Class`实例。

#### 获取继承关系

不仅可以获取当前类的`Class`对象，还能获取父类的`Class`对象。

```java
Integer integer = new Integer(10);
Class cls = integer.getClass(); //获取当前类
System.out.println(cls.getName()); //java.lang.Integer

Class superclass = cls.getSuperclass();//获取父类
System.out.println(superclass.getName());//java.lang.Number

Class superclass1 = superclass.getSuperclass();
System.out.println(superclass1.getName());//java.lang.Object

Class superclass2 = superclass1.getSuperclass(); //null
System.out.println(superclass2==null); //true
```

可以看到，`Integer`的父类是`Number`，`Number`的父类是`Object`，`Object`没有父类，获取到的为`null`。

- `Class[] getInterfaces()`：获取当前类实现的所有接口。
- 通过`Class`对象的`isAssignableFrom()`方法可以判断一个向上转型是否可以实现。

#### 动态代理

Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；

动态代理是通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成的。

### 注解

什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。

注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。

#### 定义注解

Java的注解可以分为三类：

**第一类是由编译器使用的注解**，例如：

- `@Override`：让编译器检查该方法是否正确地实现了覆写；
- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告。

这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。

第二类是由工具处理`.class`文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入`.class`文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。

**第三类是在程序运行期能够读取的注解**，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。

> 也就是下面说的元注解@Retention的三个取值：RetentionPolicy.SOURCE, RetentionPolicy.CLASS, RetentionPolicy.RUNTIME 分别代表了注解的三种生命周期，RUNTIME是最长的声明周期。



大部分注解会有一个名为`value`的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。

如果只写注解，相当于全部使用默认值。

```java
@Target(ElementType.FIELD) //元注解：可以修饰字段
@Retention(RetentionPolicy.RUNTIME)//元注解：指定生命周期到运行时
@interface Check{ //注解的定义方法
    int min() default 0; //定义参数及默认值
    int max() default 100;
    int value() default 50;
}

class Hello{
    @Check(min=0,max=100,value = 50) //指定所有参数
    public int m;
    @Check(value = 99)//指定其中一个参数
    public int n;
    @Check(99) //value值较为特殊，只有一个值时即为value
    public int x;
    @Check //所有参数都使用默认值
    public int y;
    public Hello(int m,int n,int x,int y){
        this.m = m;
        this.n = n;
        this.x = x;
        this.y = y;
    }
    @Override //注解的使用
    public String toString(){
        return m + " " + n + " " + x + " " + y;
    }
}
```



使用`@interface`语法来定义注解（`Annotation`）

```java
@interface Report{
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

#### 元注解

元注解（meta annotation）就是可以注解注解的注解，是Java标准库内置的注解。

##### **@Target**

最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：

- 类或接口：`ElementType.TYPE`； 可以用来修饰类或者接口的定义
- 字段：`ElementType.FIELD`；可以用来修饰字段
- 方法：`ElementType.METHOD`；可以用来修饰方法或函数
- 构造方法：`ElementType.CONSTRUCTOR`；可以用来修饰构造函数
- 方法参数：`ElementType.PARAMETER`。

实际上`@Target`定义的`value`是`ElementType[]`数组，只有一个元素时，可以省略数组的写法。

```java
//@Target(ElementType.TYPE) //只有一个的情况
@Target({ElementType.TYPE,ElementType.METHOD})//多个的情况，用{}
@interface Report{
  ...
}
```

##### **@Retention**

另一个重要的元注解`@Retention`定义了`Annotation`的生命周期：

- 仅编译期：`RetentionPolicy.SOURCE`；
- 仅class文件：`RetentionPolicy.CLASS`；
- 运行期：`RetentionPolicy.RUNTIME`。

如果`@Retention`不存在，则该`Annotation`默认为`CLASS`。因为通常我们自定义的`Annotation`都是`RUNTIME`，所以，务必要加上`@Retention(RetentionPolicy.RUNTIME)`这个元注解。

```java
@Retention(RetentionPolicy.RUNTIME)
@interface Report{
    ...
}
```

##### **@Repeatable**

使用`@Repeatable`这个元注解可以定义`Annotation`是否可重复。这个注解应用不是特别广泛。

##### **@Inherited**

使用`@Inherited`定义子类是否可继承父类定义的`Annotation`。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效

```java
@Inherited
@interface Report{
    ...
}

@Report(...)
public class Person{
    
}
public class Student extends Person{
    //也拥有@Report
}
```

表示如果一个类用到了`@Report`这个注解，那么他的子类默认也拥有了这个注解。注意只针对`class`.



综上，定义一个注解有三步：

1. 用@interface定义注解
2. 添加参数、默认值
3. 用元注解配置注解

```java
@Target({ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@interface Report{
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

#### 使用和处理注解

Java的注解本身对代码逻辑没有任何影响。根据`@Retention`的配置：

- `SOURCE`类型的注解在编译期就被丢掉了；
- `CLASS`类型的注解仅保存在class文件中，它们不会被加载进JVM；
- `RUNTIME`类型的注解会被加载进JVM，并且在运行期可以被程序读取。

`SOURCE`类型的注解主要由编译器使用，因此我们一般只使用，不编写。`CLASS`类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。**只有`RUNTIME`类型的注解不但要使用，还经常需要编写**。

因为注解定义后也是一种`class`，**所有的注解都继承自`java.lang.annotation.Annotation`**，因此，读取注解，需要使用反射API。

可以参考这篇博客：[@Retention注解作用](https://blog.csdn.net/m0_37840000/article/details/80921775)

##### 判断注解是否存在

Java提供的使用反射API读取`Annotation`的方法包括：

判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：

- `Class.isAnnotationPresent(Class)`
- `Field.isAnnotationPresent(Class)`
- `Method.isAnnotationPresent(Class)`
- `Constructor.isAnnotationPresent(Class)`

```java
// 判断@Report是否存在于Person类:
Person.class.isAnnotationPresent(Report.class);
```



##### 读取注解

使用反射API读取`Annotation` ：

- `Class.getAnnotation(Class)`
- `Field.getAnnotation(Class)`
- `Method.getAnnotation(Class)`
- `Constructor.getAnnotation(Class)`



使用反射API读取`Annotation`有两种方法。方法一是先判断`Annotation`是否存在，如果存在，就直接读取：

```java
Class cls = Person.class;
if (cls.isAnnotationPresent(Report.class)) {
    Report report = cls.getAnnotation(Report.class);
    ...
}
```



第二种方法是直接读取`Annotation`，如果`Annotation`不存在，将返回`null`：

```java
Class cls = Person.class;
Report report = cls.getAnnotation(Report.class);
if (report != null) {
   ...
}
```

##### *读取Method的注解

读取方法、字段和构造方法的`Annotation`和Class类似。但要**读取方法参数的`Annotation`就比较麻烦一点**，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：

参数也加了注解，而且不止一个。

```java
public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {
}
```

```java
// 获取Method实例:
Method m = ...
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) {
    if (anno instanceof Range) { // @Range注解
        Range r = (Range) anno;
    }
    if (anno instanceof NotNull) { // @NotNull注解
        NotNull n = (NotNull) anno;
    }
}
```



#### 反射+注解应用

==**定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。**==

```java
public class Main {
    public static void main(String[] args) throws Exception {
        Person person = new Person("jack","London");
        System.out.println(person);
        System.out.println(check(person)); //false

        Person person1 = new Person("jack", "Ash"); //定义对象的时候不会检查，只有调用检查函数的时候才会进行检查
        System.out.println(person1);
        System.out.println(check(person1)); //true

    }
    public static boolean check(Person p) throws IllegalAccessException {
        //传入一个Person对象，检查字段name和city是否符合注解的要求范围

        //1.先获取字段
        Class cls = p.getClass();
        Field[] fields = cls.getFields();
        for(Field field:fields){
            if(field.isAnnotationPresent(Range.class)){
                //获取注解对象以及值
                final Range range = field.getAnnotation(Range.class);
                int min = range.min();
                int max = range.max();
                //获取字段对象的值
                Object value = field.get(p);
                if(value instanceof String){
                    String s = (String)value;
                    if(s.length()<min || s.length()>max) return false;
                }
            }
        }
        return true;
    }
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Range{
    int min() default 0;
    int max() default 255;
}

class Person{
    @Range(min=1,max=5)
    public String name;

    @Range(max=3)
    public String city;

    public Person(String name, String city){
        this.name = name;
        this.city = city;
    }
    @Override
    public String toString(){
        return name + " " + city;
    }
}
```

- JUnit会自动运行`@Test`标记的测试方法。
